thumb 300px ibm s blue gene p massively parallel supercomputer parallel computing is a type of computation in which many calculations or execution of processes are carried out simultaneously large problems can often be divided into smaller ones which can then be solved at same time there are several different forms of parallel computing bit level instruction level data and task parallelism parallelism has long been employed in high performance computing but it s gaining broader interest due to physical constraints preventing frequency scaling s v et al november 2008 parallel computing research at illinois agenda pdf parallel illinois university of illinois at urbana champaign main techniques for these performance benefits increased clock frequency and smarter but increasingly complex architectures are now hitting so called power wall computer industry has accepted that future performance increases must largely come from increasing number of processors or cores on a die rather than making a single core go faster as power consumption and consequently heat generation by computers has become a concern in recent years asanovic et al old conventional wisdom power is free but transistors are expensive new conventional wisdom is that power is expensive but transistors are free parallel computing has become dominant paradigm in computer architecture mainly in form of multi core processors asanovic krste et al december 18 2006 landscape of parallel computing research a view from berkeley pdf university of california berkeley technical report no ucb eecs 2006 183 old conventional wisdom increasing clock frequency is primary method of improving processor performance new conventional wisdom increasing parallelism is primary method of improving processor performance even representatives from intel a company generally associated with higher clock speed is better position warned that traditional approaches to maximizing performance through maximizing clock speed have been pushed to their limits parallel computing is closely related to concurrent computing they are frequently used together and often conflated though two are distinct it is possible to have parallelism without concurrency such as bit level parallelism and concurrency without parallelism such as multitasking by time sharing on a single core cpu concurrency is not parallelism waza conference jan 11 2012 rob pike slides video in parallel computing a computational task is typically broken down into several often many very similar sub tasks that can be processed independently and whose results are combined afterwards upon completion in contrast in concurrent computing various processes often do not address related tasks when they do as is typical in distributed computing separate tasks may have a varied nature and often require some inter process communication during execution parallel computers can be roughly classified according to level at which hardware supports parallelism with multi core and multi processor computers having multiple processing elements within a single machine while clusters mpps and grids use multiple computers to work on same task specialized parallel computer architectures are sometimes used alongside traditional processors for accelerating specific tasks in some cases parallelism is transparent to programmer such as in bit level or instruction level parallelism but explicitly parallel algorithms particularly those that use concurrency are more difficult to write than sequential ones because concurrency introduces several new classes of potential software bugs of which race conditions are most common communication and synchronization between different subtasks are typically some of greatest obstacles to getting good parallel program performance a theoretical upper bound on speed up of a single program as a result of parallelization is given by amdahl s law background traditionally computer software has been written for serial computation to solve a problem an algorithm is constructed and implemented as a serial stream of instructions these instructions are executed on a central processing unit on one computer only one instruction may execute at a time after that instruction is finished next one is executed parallel computing on other hand uses multiple processing elements simultaneously to solve a problem this is accomplished by breaking problem into independent parts so that each processing element can execute its part of algorithm simultaneously with others processing elements can be diverse and include resources such as a single computer with multiple processors several networked computers specialized hardware or any combination of above historically parallel computing was used for scientific computing and simulation of scientific problems particularly in natural and engineering sciences such as meteorology this led to design of parallel hardware and software as well as high performance computing frequency scaling was dominant reason for improvements in computer performance from mid 1980s until 2004 runtime of a program is equal to number of instructions multiplied by average time per instruction maintaining everything else constant increasing clock frequency decreases average time it takes to execute an instruction an increase in frequency thus decreases runtime for all compute bound programs however power consumption p by a chip is given by equation p c x v 2 x f where c is capacitance being switched per clock cycle proportional to number of transistors whose inputs change v is voltage and f is processor frequency cycles per second increases in frequency increase amount of power used in a processor increasing processor power consumption led ultimately to intel s may 8 2004 cancellation of its tejas and jayhawk processors which is generally cited as end of frequency scaling as dominant computer architecture paradigm to deal with problem of power consumption and overheating major central processing unit cpu or processor manufacturers started to produce power efficient processors with multiple cores core is computing unit of processor and in multi core processors each core is independent and can access same memory concurrently multi core processors have brought parallel computing to desktop computers thus of serial programmes has become a mainstream programming task in 2012 quad core processors became standard for desktop computers while servers have 10 and 12 core processors from moore s law it can be predicted that number of cores per processor will double every 18 24 months this could mean that after 2020 a typical processor will have dozens or hundreds of cores an operating system can ensure that different tasks and user programmes are run in parallel on available cores however for a serial software programme to take full advantage of multi core architecture programmer needs to restructure and parallelise code a speed up of application software runtime will no longer be achieved through frequency scaling instead programmers will need to parallelise their software code to take advantage of increasing computing power of multicore architectures amdahl s law and gustafson s law right thumbnail 300px a graphical representation of amdahl s law speedup of a program from parallelization is limited by how much of program can be parallelized for example if 90 of program can be parallelized theoretical maximum speedup using parallel computing would be 10 times no matter how many processors are used file optimizing different parts svg thumb 300px assume that a task has two independent parts a and b part b takes roughly 25 of time of whole computation by working very hard one may be able to make this part 5 times faster but this only reduces time for whole computation by a little in contrast one may need to perform less work to make part a be twice as fast this will make computation much faster than by optimizing part b even though part b s speedup is greater by ratio 5 times versus 2 times optimally speedup from parallelization would be linear doubling number of processing elements should halve runtime and doubling it a second time should again halve runtime however very few parallel algorithms achieve optimal speedup most of them have a near linear speedup for small numbers of processing elements which flattens out into a constant value for large numbers of processing elements potential speedup of an algorithm on a parallel computing platform is given by amdahl s law where is potential speedup in latency of execution of whole task s is speedup in latency of execution of parallelizable part of task p is percentage of execution time of whole task concerning parallelizable part of task before parallelization since it shows that a small part of program which cannot be parallelized will limit overall speedup available from parallelization a program solving a large mathematical or engineering problem will typically consist of several parallelizable parts and several non parallelizable serial parts if non parallelizable part of a program accounts for 10 of runtime p 0 9 we can get no more than a 10 times speedup regardless of how many processors are added this puts an upper limit on usefulness of adding more parallel execution units when a task cannot be partitioned because of sequential constraints application of more effort has no effect on schedule bearing of a child takes nine months no matter how many women are assigned thumb right 300px a graphical representation of gustafson s law amdahl s law only applies to cases where problem size is fixed in practice as more computing resources become available they tend to get used on larger problems larger datasets and time spent in parallelizable part often grows much faster than inherently serial work in this case gustafson s law gives a less pessimistic and more realistic assessment of parallel performance both amdahl s law and gustafson s law assume that running time of serial part of program is independent of number of processors amdahl s law assumes that entire problem is of fixed size so that total amount of work to be done in parallel is also independent of number of processors whereas gustafson s law assumes that total amount of work to be done in parallel varies linearly with number of processors dependencies understanding data dependencies is fundamental in implementing parallel algorithms no program can run more quickly than longest chain of dependent calculations known as critical path since calculations that depend upon prior calculations in chain must be executed in order however most algorithms do not consist of just a long chain of dependent calculations there are usually opportunities to execute independent calculations in parallel let pi and pj be two program segments bernstein s conditions describe when two are independent and can be executed in parallel for pi let ii be all of input variables and oi output variables and likewise for pj pi and pj are independent if they satisfy violation of first condition introduces a flow dependency corresponding to first segment producing a result used by second segment second condition represents an anti dependency when second segment produces a variable needed by first segment third and final condition represents an output dependency when two segments write to same location result comes from logically last executed segment consider following functions which demonstrate several kinds of dependencies 1 function dep a b 2 c a b 3 d 3 c 4 end function in this example instruction 3 cannot be executed before or even in parallel with instruction 2 because instruction 3 uses a result from instruction 2 it violates condition 1 and thus introduces a flow dependency 1 function a b 2 c a b 3 d 3 b 4 e a b 5 end function in this example there are no dependencies between instructions so they can all be run in parallel bernstein s conditions do not allow memory to be shared between different processes for that some means of enforcing an ordering between accesses is necessary such as barriers or some other synchronization method race conditions mutual exclusion synchronization and parallel slowdown subtasks in a parallel program are often called threads some parallel computer architectures use smaller lightweight versions of threads known as fibers while others use bigger versions known as processes however threads is generally accepted as a generic term for subtasks threads will often need synchronized access to an object or other resource for example when they must update a variable that is shared between them without synchronization instructions between two threads may be interleaved in any order for example consider following program thread athread b1a read variable v1b read variable v2a add 1 to variable v2b add 1 to variable v3a write back to variable v3b write back to variable v if instruction 1b is executed between 1a and 3a or if instruction 1a is executed between 1b and 3b program will produce incorrect data this is known as a race condition programmer must use a lock to provide mutual exclusion a lock is a programming language construct that allows one thread to take control of a variable and prevent other threads from reading or writing it until that variable is unlocked thread holding lock is free to execute its critical section section of a program that requires exclusive access to some variable and to unlock data when it is finished therefore to guarantee correct program execution above program can be rewritten to use locks thread athread b1a lock variable v1b lock variable v2a read variable v2b read variable v3a add 1 to variable v3b add 1 to variable write back to variable write back to variable unlock variable unlock variable v one thread will successfully lock variable v while other thread will be locked out unable to proceed until v is unlocked again this guarantees correct execution of program locks may be necessary to ensure correct program execution when threads must serialize access to resources but their use can greatly slow a program and may affect its reliability locking multiple variables using non atomic locks introduces possibility of program deadlock an atomic lock locks multiple variables all at once if it cannot lock all of them it does not lock any of them if two threads each need to lock same two variables using non atomic locks it is possible that one thread will lock one of them and second thread will lock second variable in such a case neither thread can complete and deadlock results many parallel programs require that their subtasks act in synchrony this requires use of a barrier barriers are typically implemented using a lock or a semaphore one class of algorithms known as lock free and wait free algorithms altogether avoids use of locks and barriers however this approach is generally difficult to implement and requires correctly designed data structures not all parallelization results in speed up generally as a task is split up into more and more threads those threads spend an ever increasing portion of their time communicating with each other or waiting on each other for access to resources once overhead from resource contention or communication dominates time spent on other computation further parallelization that is splitting workload over even more threads increases rather than decreases amount of time required to finish this problem known as parallel slowdown can be improved in some cases by software analysis and redesign fine grained coarse grained and embarrassing parallelism applications are often classified according to how often their subtasks need to synchronize or communicate with each other an application exhibits fine grained parallelism if its subtasks must communicate many times per second it exhibits coarse grained parallelism if they do not communicate many times per second and it exhibits embarrassing parallelism if they rarely or never have to communicate embarrassingly parallel applications are considered easiest to consistency models parallel programming languages and parallel computers must have a consistency model also known as a memory model consistency model defines rules for how operations on computer memory occur and how results are produced one of first consistency models was leslie lamport s sequential consistency model sequential consistency is property of a parallel program that its parallel execution produces same results as a sequential program specifically a program is sequentially consistent if results of any execution is same as if operations of all processors were executed in some sequential order and operations of each individual processor appear in this sequence in order specified by its program software transactional memory is a common type of consistency model software transactional memory borrows from database theory concept of atomic transactions and applies them to memory accesses mathematically these models can be represented in several ways introduced in 1962 petri nets were an early attempt to codify rules of consistency models dataflow theory later built upon these and dataflow architectures were created to physically implement ideas of dataflow theory beginning in late 1970s process such as calculus of communicating systems and communicating sequential processes were developed to permit algebraic reasoning about systems composed of interacting components more recent additions to process calculus family such as p calculus have added capability for reasoning about dynamic topologies logics such as lamport s tla and mathematical models such as traces and actor event diagrams have also been developed to describe behavior of concurrent systems flynn s taxonomy michael j flynn created one of earliest classification systems for parallel and sequential computers and programs now known as flynn s taxonomy flynn classified programs and computers by whether they were operating using a single set or multiple sets of instructions and whether or not those instructions were using a single set or multiple sets of data single instruction single data classification is equivalent to an entirely sequential program single instruction multiple data simd classification is analogous to doing same operation repeatedly over a large data set this is commonly done in signal processing applications multiple instruction single data is a rarely used classification while computer architectures to deal with this were devised such as systolic arrays few applications that fit this class materialized multiple instruction multiple data mimd programs are by far most common type of parallel programs according to david a patterson and john l hennessy some machines are hybrids of these categories of course but this classic model has survived because it is simple easy to understand and gives a good first approximation it is also perhaps because of its most widely used scheme patterson and hennessy p 748 types of parallelism bit level parallelism from advent of very large scale integration vlsi computer chip fabrication technology in 1970s until about 1986 speed up in computer architecture was driven by doubling computer word size amount of information processor can manipulate per cycle increasing word size reduces number of instructions processor must execute to perform an operation on variables whose sizes are greater than length of word for example where an 8 bit processor must add two 16 bit integers processor must first add 8 lower order bits from each integer using standard addition instruction then add 8 higher order bits using an add with carry instruction and carry bit from lower order addition thus an 8 bit processor requires two instructions to complete a single operation where a 16 bit processor would be able to complete operation with a single instruction historically 4 bit microprocessors were replaced with 8 bit then 16 bit then 32 bit microprocessors this trend generally came to an end with introduction of 32 bit processors which has been a standard in general purpose computing for two decades not until early 2000s with advent of x86 64 architectures did 64 bit processors become commonplace instruction level parallelism thumb 300px a canonical processor without pipeline it takes five clock cycles to complete one instruction and thus processor can issue subscalar performance thumb 300px a canonical five stage pipelined processor in best case scenario it takes one clock cycle to complete one instruction and thus processor can issue scalar performance a computer program is in essence a stream of instructions executed by a processor without instruction level parallelism a processor can only issue less than one instruction per clock cycle these processors are known as subscalar processors these instructions can be re ordered and combined into groups which are then executed in parallel without changing result of program this is known as instruction level parallelism advances in instruction level parallelism dominated computer architecture from mid 1980s until mid 1990s culler et al p 15 all modern processors have multi stage instruction pipelines each stage in pipeline corresponds to a different action processor performs on that instruction in that stage a processor with an n stage pipeline can have up to n different instructions at different stages of completion and thus can issue one instruction per clock cycle these processors are known as scalar processors canonical example of a pipelined processor is a risc processor with five stages instruction fetch if instruction decode id execute ex memory access mem and register write back wb pentium 4 processor had a 35 stage pipeline yale april 2004 microprocessor ten years from now what are challenges how do we meet them wmv distinguished lecturer talk at carnegie mellon university retrieved on november 7 2007 thumb 300px a canonical five stage pipelined superscalar processor in best case scenario it takes one clock cycle to complete two instructions and thus processor can issue superscalar performance most modern processors also have multiple execution units they usually combine this feature with and thus can issue more than one instruction per clock cycle these processors are known as superscalar processors instructions can be grouped together only if there is no data dependency between them scoreboarding and algorithm which is similar to scoreboarding but makes use of register renaming are two of most common techniques for implementing out of order execution and instruction level parallelism task parallelism task parallelisms is characteristic of a parallel program that entirely different calculations can be performed on either same or different sets of data culler et al p 124 this contrasts with data parallelism where same calculation is performed on same or different sets of data task parallelism involves decomposition of a task into sub tasks and then allocating each sub task to a processor for execution processors would then execute these sub tasks concurrently and often cooperatively task parallelism does not usually scale with size of a problem culler et al p 125 hardware memory and communication main memory in a parallel computer is either shared memory shared between all processing elements in a single address space or distributed memory in which each processing element has its own local address space patterson and hennessy p 713 distributed memory refers to fact that memory is logically distributed but often implies that it is physically distributed as well distributed shared memory and memory virtualization combine two approaches where processing element has its own local memory and access to memory on non local processors accesses to local memory are typically faster than accesses to non local memory on supercomputers distributed shared memory space can be implemented using programming model such as this model allows processes on one compute node to transparently access remote memory of another compute node all compute nodes are also connected to an external shared memory system via high speed interconnect such as infiniband this external shared memory system is known as burst buffer which is typically built from arrays of non volatile memory physically distributed across multiple i o nodes right thumbnail 400px a logical view of a non uniform memory access numa architecture processors in one directory can access that directory s memory with less latency than they can access memory in other directory s memory computer architectures in which each element of main memory can be accessed with equal latency and bandwidth are known as uniform memory access uma systems typically that can be achieved only by a shared memory system in which memory is not physically distributed a system that does not have this property is known as a non uniform memory access numa architecture distributed memory systems have non uniform memory access computer systems make use of caches small and fast memories located close to processor which store temporary copies of memory values nearby in both physical and logical sense parallel computer systems have difficulties with caches that may store same value in more than one location with possibility of incorrect program execution these computers require a cache coherency system which keeps track of cached values and strategically purges them thus ensuring correct program execution bus snooping is one of most common methods for keeping track of which values are being accessed and thus should be purged designing large high performance cache coherence systems is a very difficult problem in computer architecture as a result shared memory computer architectures do not scale as well as distributed memory systems do processor processor and processor memory communication can be implemented in hardware in several ways including via shared either or multiplexed memory a crossbar switch a shared bus or an interconnect network of a myriad of topologies including star ring tree hypercube fat hypercube a hypercube with more than one processor at a node or n dimensional mesh parallel computers based on interconnected networks need to have some kind of routing to enable passing of messages between nodes that are not directly connected medium used for communication between processors is likely to be hierarchical in large multiprocessor machines classes of parallel computers parallel computers can be roughly classified according to level at which hardware supports parallelism this classification is broadly analogous to distance between basic computing nodes these are not mutually exclusive for example clusters of symmetric multiprocessors are relatively common multi core computing a multi core processor is a processor that includes multiple processing units called cores on same chip this processor differs from a superscalar processor which includes multiple execution units and can issue multiple instructions per clock cycle from one instruction stream thread in contrast a multi core processor can issue multiple instructions per clock cycle from multiple instruction streams ibm s cell microprocessor designed for use in sony playstation 3 is a prominent multi core processor each core in a multi core processor can potentially be superscalar as well that is on every clock cycle each core can issue multiple instructions from one thread simultaneous multithreading of which intel s hyper threading is best known was an early form of pseudo multi a processor capable of concurrent multithreading includes multiple execution units in same processing unit that is it has a superscalar architecture and can issue multiple instructions per clock cycle from multiple threads temporal multithreading on other hand includes a single execution unit in same processing unit and can issue one instruction at a time from multiple threads symmetric multiprocessing a symmetric multiprocessor smp is a computer system with multiple identical processors that share memory and connect via a bus hennessy and patterson p 549 bus contention prevents bus architectures from scaling as a result generally do not comprise more than 32 processors patterson and hennessy p 714 because of small size of processors and significant reduction in requirements for bus bandwidth achieved by large caches such symmetric multiprocessors are extremely cost effective provided that a sufficient amount of memory bandwidth exists distributed computing a distributed computer also known as a distributed memory multiprocessor is a distributed memory computer system in which processing elements are connected by a network distributed computers are highly scalable terms concurrent computing parallel computing and distributed computing have a lot of overlap and no clear distinction exists between them ghosh 2007 p 10 2008 same system may be characterized both as parallel and distributed processors in a typical distributed system run concurrently in parallel lynch 1996 p xix 1 2 peleg 2000 p 1 cluster computing right thumbnail upright a beowulf cluster a cluster is a group of loosely coupled computers that work together closely so that in some respects they can be regarded as a single computer what is clustering computer dictionary retrieved on november 7 2007 clusters are composed of multiple standalone machines connected by a network while machines in a cluster do not have to be symmetric load balancing is more difficult if they are not most common type of cluster is beowulf cluster which is a cluster implemented on multiple identical commercial off shelf computers connected with a tcp ip ethernet local area network beowulf definition pc magazine retrieved on november 7 2007 beowulf technology was originally developed by thomas sterling and donald becker 87 of all top500 supercomputers are clusters remaining are massively parallel processors explained below because grid computing systems described below can easily handle embarrassingly parallel problems modern clusters are typically designed to handle more difficult problems problems that require nodes to share intermediate results with each other more often this requires a high bandwidth and more importantly a low latency interconnection network many historic and current supercomputers use customized high performance network hardware specifically designed for cluster computing such as cray gemini network interconnect as of 2014 most current supercomputers use some off shelf standard network hardware often infiniband or gigabit ethernet massively parallel computing right thumbnail upright a cabinet from ibm s blue gene l massively parallel supercomputer a massively parallel processor mpp is a single computer with many networked processors mpps have many of same characteristics as clusters but mpps have specialized interconnect networks whereas clusters use commodity hardware for networking mpps also tend to be larger than clusters typically having far more than 100 processors hennessy and patterson p 537 in an mpp each cpu contains its own memory and copy of operating system and application each subsystem communicates with others via a high speed interconnect mpp definition pc magazine retrieved on november 7 2007 ibm s blue gene l fifth fastest supercomputer in world according to june 2009 top500 ranking is an mpp grid computing grid computing is most distributed form of parallel computing it makes use of computers communicating over internet to work on a given problem because of low bandwidth and extremely high latency available on internet distributed computing typically deals only with embarrassingly parallel problems many distributed computing applications have been created of which seti home and folding home are best known examples most grid computing applications use middleware software that sits between operating system and application to manage network resources and standardize software interface most common distributed computing middleware is berkeley open infrastructure for network computing often distributed computing software makes use of spare cycles performing computations at times when a computer is idling specialized parallel computers within parallel computing there are specialized parallel devices that remain niche areas of interest while not domain specific they tend to be applicable to only a few classes of parallel problems reconfigurable computing with field programmable gate arrays reconfigurable computing is use of a field programmable gate array fpga as a co processor to a general purpose computer an fpga is in essence a computer chip that can rewire itself for a given task fpgas can be programmed with hardware description languages such as vhdl or verilog however programming in these languages can be tedious several vendors have created c to hdl languages that attempt to emulate syntax and semantics of c programming language with which most programmers are familiar best known c to hdl languages are mitrion c impulse c dime c and handel c specific subsets of based on c can also be used for this purpose amd s decision to open its technology to third party vendors has become enabling technology for high performance reconfigurable computing d amour michael r chief operating officer drc computer corporation standard reconfigurable computing invited speaker at university of delaware february 28 2007 according to michael r d amour chief operating officer of drc computer corporation when we first walked into amd they called us socket stealers now they call us their partners general purpose computing on graphics processing units gpgpu right thumbnail nvidia s tesla gpgpu card general purpose computing on graphics processing units gpgpu is a fairly recent trend in computer engineering research gpus are co processors that have been heavily optimized for computer graphics processing sha kia and daniel m august 2007 gpus an emerging platform for general purpose computation pdf arl sr 154 u s army research lab retrieved on november 7 2007 computer graphics processing is a field dominated by data parallel operations particularly linear algebra matrix operations in early days gpgpu programs used normal graphics apis for executing programs however several new programming languages and platforms have been built to do general purpose computation on gpus with both nvidia and amd releasing programming environments with and stream sdk respectively other gpu programming languages include and nvidia has also released specific products for computation in their tesla series technology consortium group has released opencl specification which is a framework for writing programs that execute across platforms consisting of cpus and gpus amd apple intel nvidia and others are supporting opencl application specific integrated circuits several application specific integrated circuit asic approaches have been devised for dealing with parallel applications oleg 2002 systematic generation of executing programs for processor elements in parallel asic or fpga based systems and their transformation into vhdl descriptions of processor element control units lecture notes in computer science 2328 2002 p 272 because an asic is by definition specific to a given application it can be fully optimized for that application as a result for a given application an asic tends to outperform a general purpose computer however asics are created by uv this process requires a mask set which can be extremely expensive a mask set can cost over a million us dollars kahng andrew b june 21 2004 scoping problem of dfm in semiconductor industry university of california san diego future design for manufacturing dfm technology must reduce design non recoverable expenditure cost and directly address manufacturing non recoverable expenditures cost of a mask set and probe card which is well over 1 million at 90 nm technology node and creates a significant damper on semiconductor based innovation smaller transistors required for chip more expensive mask will be meanwhile performance increases in general purpose computing over time as described by moore s law tend to wipe out these gains in only one or two chip generations high initial cost and tendency to be overtaken by moore s law driven general purpose computing has rendered asics unfeasible for most parallel computing applications however some have been built one example is riken 3 machine which uses custom asics for molecular dynamics simulation vector processors right thumbnail cray 1 is a vector processor a vector processor is a cpu or computer system that can execute same instruction on large sets of data vector processors have high level operations that work on linear arrays of numbers or vectors an example vector operation is a b x c where a b and c are each 64 element vectors of 64 bit floating point numbers patterson and hennessy p 751 they are closely related to flynn s simd classification cray computers became famous for their vector processing computers in 1970s and 1980s however vector processors both as cpus and as full computer systems have generally disappeared modern processor instruction sets do include some vector processing instructions such as with semiconductor s and intel s streaming simd extensions sse software parallel programming languages concurrent programming languages libraries apis and parallel programming models such as algorithmic skeletons have been created for programming parallel computers these can generally be divided into classes based on assumptions they make about underlying memory architecture shared memory distributed memory or shared distributed memory shared memory programming languages communicate by manipulating shared memory variables distributed memory uses message passing posix threads and are two of most widely used shared memory apis whereas message passing interface mpi is most widely used message passing system api sidney fernbach award given to mpi inventor bill gropp refers to mpi as dominant hpc communications interface one concept used in programming parallel programs is future concept where one part of a program promises to deliver a required datum to another part of a program at some future time caps entreprise and are also coordinating their effort to make hybrid multi core parallel programming directives an open standard called openhmpp openhmpp directive based programming model offers a syntax to efficiently offload computations on hardware accelerators and to optimize data movement to from hardware memory openhmpp directives describe remote procedure call rpc on an accelerator device e g gpu or more generally a set of cores directives annotate c or fortran codes to describe two sets of functionalities offloading of procedures denoted onto a remote device and optimization of data transfers between cpu main memory and accelerator memory rise of consumer gpus has led to support for compute kernels either in graphics apis referred to as compute shaders in dedicated apis such as opencl or in other language extensions automatic parallelization automatic parallelization of a sequential program by a compiler is holy grail of parallel computing especially with aforementioned limit of processor frequency despite decades of work by compiler researchers automatic parallelization has had only limited success mainstream parallel programming languages remain either explicitly parallel or at best partially implicit in which a programmer gives compiler directives for parallelization a few fully implicit parallel programming languages exist sisal parallel haskell system c for fpgas mitrion c vhdl and verilog application checkpointing as a computer system grows in complexity mean time between failures usually decreases application checkpointing is a technique whereby computer system takes a snapshot of application a record of all current resource allocations and variable states akin to a core dump this information can be used to restore program if computer should fail application checkpointing means that program has to restart from only its last checkpoint rather than beginning while checkpointing provides benefits in a variety of situations it is especially useful in highly parallel systems with a large number of processors used in high performance computing encyclopedia of parallel computing volume 4 by david padua 2011 page 265 algorithmic methods as parallel computers become larger and faster we are now able to solve problems that had previously taken too long to run fields as varied as bioinformatics for protein folding and sequence analysis and economics for mathematical finance have taken advantage of parallel computing common types of problems in parallel computing applications include asanovic krste et al december 18 2006 landscape of parallel computing research a view from berkeley pdf university of california berkeley technical report no ucb eecs 2006 183 see table on pages 17 19 dense linear algebra sparse linear algebra spectral methods such as cooley tukey fast fourier transform n body problems such as barnes hut simulation structured grid problems such as lattice boltzmann methods unstructured grid problems such as found in finite element analysis monte carlo method logic such as brute force cryptographic techniques graph traversal such as sorting algorithms dynamic programming branch and bound methods graphical models such as detecting hidden markov models and constructing bayesian networks finite state machine simulation fault tolerance parallel computing can also be applied to design of fault tolerant computer systems particularly via lockstep systems performing same operation in parallel this provides redundancy in case one component fails and also allows automatic error detection and error correction if results differ these methods can be used to help prevent single event upsets caused by transient errors b hartig h engel m 2012 operating system support for redundant multithreading proceedings of tenth acm international conference on embedded software 83 92 although additional measures may be required in embedded or specialized systems this method can provide a cost effective approach to achieve n modular redundancy in commercial off shelf systems history right thumbnail illiac iv most infamous of supercomputers origins of true mimd parallelism go back to luigi federico menabrea and his sketch of analytic engine invented by charles babbage menabrea l f 1842 sketch of analytic engine invented by charles babbage bibliotheque universelle de geneve retrieved on november 7 2007 quote when a long series of identical computations is to be performed such as those required for formation of numerical tables machine can be brought into play so as to give several results at same time which will greatly whole amount of processes patterson and hennessy p 753 r w hockney c r parallel computers 2 architecture programming and algorithms volume 2 1988 p 8 quote earliest reference to parallelism in computer design is thought to be in general l f menabrea s publication in 1842 entitled sketch of analytical engine invented by charles babbage in april 1958 s gill ferranti discussed parallel programming and need for branching and waiting parallel programming s gill computer journal vol 1 1 pp2 10 british computer society april 1958 also in 1958 ibm researchers john cocke and daniel slotnick discussed use of parallelism in numerical calculations for first time burroughs corporation introduced in 1962 a four processor computer that accessed up to 16 memory modules through a crossbar switch in 1967 amdahl and slotnick published a debate about feasibility of parallel processing at american federation of information processing societies conference it was during this debate that amdahl s law was coined to define limit of speed up due to parallelism in 1969 honeywell introduced its first multics system a symmetric multiprocessor system capable of running up to eight processors in parallel c mmp a multi processor project at carnegie mellon university in 1970s was among first multiprocessors with more than a few processors first bus connected multiprocessor with snooping caches was synapse n 1 in 1984 simd parallel computers can be traced back to 1970s motivation behind early simd computers was to gate delay of processor s control unit over multiple instructions patterson and hennessy p 749 in 1964 slotnick had proposed building a massively parallel computer for lawrence livermore national laboratory his design was funded by us air force which was earliest simd parallel computing effort illiac iv key to its design was a fairly high parallelism with up to 256 processors which allowed machine to work on large datasets in what would later be known as vector processing however illiac iv was called most infamous of supercomputers because project was only one fourth completed but took 11 years and cost almost four times original estimate patterson and hennessy pp 749 50 although successful in pushing several technologies useful in later projects illiac iv failed as a computer costs escalated from 8 million estimated in 1966 to 31 million by 1972 despite construction of only a quarter of planned machine it was perhaps most infamous of supercomputers project started in 1965 and ran its first real application in 1976 when it was finally ready to run its first real application in 1976 it was outperformed by existing commercial supercomputers such as cray 1 biological brain as massively parallel computer in early 1970s at mit computer science and artificial intelligence laboratory marvin minsky and seymour started developing society of mind theory which views biological brain as massively parallel computer in 1986 minsky published society of mind which claims that mind is formed from many little agents each mindless by itself theory attempts to explain how what we call intelligence could be a product of interaction of non intelligent parts minsky says that biggest source of ideas about theory came from his work in trying to create a machine that uses a robotic arm a video camera and a computer to build with children s blocks similar models which also view biological brain as a massively parallel computer i e brain is made up of a constellation of independent or semi independent agents were also described by thomas r blakeslee michael s gazzaniga robert e ornstein ernest hilgard michio kaku george ivanovich gurdjieff brain model see also concurrency computer science content parallel processor list of distributed computing conferences list of important publications in concurrent parallel and distributed computing multi tasking parallel programming model synchronous programming vector processing references further reading a parallel computing in photogrammetry gim international 1 2016 pp 21 23 external links instructional videos on caf in fortran standard by john reid see appendix b lawrence livermore national laboratory introduction to parallel computing designing and building parallel programs by ian foster internet parallel computing archive parallel processing topic area at ieee distributed computing online parallel computing works free on line book frontiers of supercomputing free on line book covering topics like algorithms and industrial applications universal parallel computing research center course in parallel programming at columbia university in collaboration with ibm t j watson x10 project parallel and distributed grobner bases computation in jas see also grobner basis course in parallel computing at university of wisconsin madison berkeley par lab progress in parallel computing landscape editors david patterson dennis gannon and michael august 23 2013 trouble with multicore by david patterson posted 30 jun 2010 landscape of parallel computing research a view from berkeley one too many dead link at this site introduction to parallel computing parallel programming category parallel computing category concurrent computing category distributed computing