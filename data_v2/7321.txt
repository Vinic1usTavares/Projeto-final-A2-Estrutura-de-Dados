in computer science binary search also known as half interval search logarithmic search or binary chop is a search algorithm that finds position of a target value within a sorted array binary search compares target value to middle element of array if they are not equal half in which target cannot lie is eliminated and search continues on remaining half again taking middle element to compare to target value and repeating this until target value is found if search ends with remaining half being empty target is not in array binary search runs in logarithmic time in worst case making comparisons where is number of elements in array is big o notation and is logarithm binary search is faster than linear search except for small arrays however array must be sorted first to be able to apply binary search there are specialized data structures designed for fast searching such as hash tables that can be searched more efficiently than binary search however binary search can be used to solve a wider range of problems such as finding next smallest or next largest element in array relative to target even if it is absent from array there are numerous variations of binary search in particular fractional cascading speeds up binary searches for same value in multiple arrays fractional cascading efficiently solves a number of search problems in computational geometry and in numerous other fields exponential search extends binary search to unbounded lists binary search tree and b tree data structures are based on binary search algorithm binary search works on sorted arrays binary search begins by comparing an element in middle of array with target value if target value matches element its position in array is returned if target value is less than element search continues in lower half of array if target value is greater than element search continues in upper half of array by doing this algorithm eliminates half in which target value cannot lie in each iteration procedure given an array of elements with values or records sorted such that and target value following subroutine uses binary search to find index of in set to and to if search terminates as unsuccessful set position of middle element to floor of which is greatest integer less than or equal to if set to and go to step 2 if set to and go to step 2 now search is done return this iterative procedure keeps track of search boundaries with two variables and procedure may be expressed in pseudocode as follows where variable names and types remain same as above floor is floor function and unsuccessful refers to a specific value that conveys failure of search function binary search a n t l 0 r n 1 while l r m floor l r 2 if a m t l m 1 else if a m t r m 1 else return m return unsuccessful alternatively algorithm may take ceiling of or least integer greater than or equal to this may change result if target value appears more than once in array alternative procedure in above procedure algorithm checks whether middle element is equal to target in every iteration some implementations leave out this check during each iteration algorithm would perform this check only when one element is left when this results in a faster comparison loop as one comparison is eliminated per iteration however it requires one more iteration on average procedure is described at p 214 titled program for binary search hermann bottenbruch published first implementation to leave out this check in 1962 set to and to while set position of middle element to ceiling of which is least integer greater than or equal to if set to else set to now search is done if return otherwise search terminates as unsuccessful where ceil is ceiling function pseudocode for this version is function binary search alternative a n t l 0 r n 1 while l r m ceil l r 2 if a m t r m 1 else l m if a l t return l return unsuccessful duplicate elements procedure may return any index whose element is equal to target value even if there are duplicate elements in array for example if array to be searched was and target was then it would be correct for algorithm to either return 4th index 3 or 5th index 4 element regular procedure would return 4th element index 3 in this case it does not always return first duplicate consider which still returns 4th element however it is sometimes necessary to find leftmost element or rightmost element for a target value that is duplicated in array in above example 4th element is leftmost element of value 4 while 5th element is rightmost element of value 4 alternative procedure above will always return index of rightmost element if such an element exists procedure for finding leftmost element to find leftmost element following procedure can be used set to and to while set position of middle element to floor of which is greatest integer less than or equal to if set to else set to return if and then is leftmost element that equals even if is not in array is rank of in array or number of elements in array that are less than where floor is floor function pseudocode for this version is function binary search leftmost a n t l 0 r n while l r m floor l r 2 if a m t l m 1 else r m return l procedure for finding rightmost element to find rightmost element following procedure can be used set to and to while set position of middle element to floor of which is greatest integer less than or equal to if set to else set to return if and then is rightmost element that equals even if is not in array is number of elements in array that are greater than where floor is floor function pseudocode for this version is function binary search rightmost a n t l 0 r n while l r m floor l r 2 if a m t r m else l m 1 return l 1 approximate matches thumb upright 1 7 binary search can be adapted to compute approximate matches in example above rank predecessor successor and nearest neighbor are shown for target value which is not in array above procedure only performs exact matches finding position of a target value however it is trivial to extend binary search to perform approximate matches because binary search operates on sorted arrays for example binary search can be used to compute for a given value its rank number of smaller elements predecessor next smallest element successor next largest element and nearest neighbor range queries seeking number of elements between two values can be performed with two rank queries rank queries can be performed with procedure for finding leftmost element number of elements less than target value is returned by procedure predecessor queries can be performed with rank queries if rank of target value is its predecessor is for successor queries procedure for finding rightmost element can be used if result of running procedure for target value is then successor of target value is nearest neighbor of target value is either its predecessor or successor whichever is closer range queries are also straightforward once ranks of two values are known number of elements greater than or equal to first value and less than second is difference of two ranks this count can be adjusted up or down by one according to whether endpoints of range should be considered to be part of range and whether array contains entries matching those endpoints performance thumb a tree representing binary search array being searched here is and target value is thumb upright 2 worst case is reached when search reaches deepest level of tree while best case is reached when target value is middle element in terms of number of comparisons performance of binary search can be analyzed by viewing run of procedure on a binary tree root node of tree is middle element of array middle element of lower half is left child node of root and middle element of upper half is right child node of root rest of tree is built in a similar fashion starting from root node left or right subtrees are traversed depending on whether target value is less or more than node under consideration in worst case binary search makes iterations of comparison loop where notation denotes floor function that yields greatest integer less than or equal to argument and is binary logarithm this is because worst case is reached when search reaches deepest level of tree and there are always levels in tree for any binary search worst case may also be reached when target element is not in array if is one less than a power of two then this is always case otherwise search may perform iterations if search reaches deepest level of tree however it may make iterations which is one less than worst case if search ends at second deepest level of tree on average assuming that each element is equally likely to be searched binary search makes iterations when target element is in array this is approximately equal to iterations when target element is not in array binary search makes iterations on average assuming that range between and outside elements is equally likely to be searched in best case where target value is middle element of array its position is returned after one iteration in terms of iterations no search algorithm that works only by comparing elements can exhibit better average and worst case performance than binary search comparison tree representing binary search has fewest levels possible as every level above lowest level of tree is filled completely otherwise search algorithm can eliminate few elements in an iteration increasing number of iterations required in average and worst case this is case for other search algorithms based on comparisons as while they may work faster on some target values average performance over all elements is worse than binary search by dividing array in half binary search ensures that size of both are as similar as possible space complexity binary search requires three pointers to elements which may be array indices or pointers to memory locations regardless of size of array however it requires at least bits to encode a pointer to an element of an array with elements therefore space complexity of binary search is in addition it takes space to store array derivation of average case average number of iterations performed by binary search depends on probability of each element being searched average case is different for successful searches and unsuccessful searches it will be assumed that each element is equally likely to be searched for successful searches for unsuccessful searches it will be assumed that intervals between and outside elements are equally likely to be searched average case for successful searches is number of iterations required to search every element exactly once divided by number of elements average case for unsuccessful searches is number of iterations required to search an element within every interval exactly once divided by intervals successful searches in binary tree representation a successful search can be represented by a path from root to target node called an internal path length of a path is number of edges connections between nodes that path passes through number of iterations performed by a search given that corresponding path has length is counting initial iteration internal path length is sum of lengths of all unique internal paths since there is only one path from root to any single node each internal path represents a search for a specific element if there are elements which is a positive integer and internal path length is then average number of iterations for a successful search with one iteration added to count initial iteration since binary search is optimal algorithm for searching with comparisons this problem is reduced to calculating minimum internal path length of all binary trees with nodes which is equal to for example in a 7 element array root requires one iteration two elements below root require two iterations and four elements below require three iterations in this case internal path length is average number of iterations would be based on equation for average case sum for can be simplified to substituting equation for into equation for for integer this is equivalent to equation for average case on a successful search specified above unsuccessful searches unsuccessful searches can be represented by augmenting tree with external nodes which forms an extended binary tree if an internal node or a node present in tree has fewer than two child nodes then additional child nodes called external nodes are added so that each internal node has two children by doing so an unsuccessful search can be represented as a path to an external node whose parent is single element that remains during last iteration an external path is a path from root to an external node external path length is sum of lengths of all unique external paths if there are elements which is a positive integer and external path length is then average number of iterations for an unsuccessful search with one iteration added to count initial iteration external path length is divided by instead of because there are external paths representing intervals between and outside elements of array this problem can similarly be reduced to determining minimum external path length of all binary trees with nodes for all binary trees external path length is equal to internal path length plus substituting equation for substituting equation for into equation for average case for unsuccessful searches can be determined performance of alternative procedure each iteration of binary search procedure defined above makes one or two comparisons checking if middle element is equal to target in each iteration assuming that each element is equally likely to be searched each iteration makes 1 5 comparisons on average a variation of algorithm checks whether middle element is equal to target at end of search on average this eliminates half a comparison from each iteration this slightly cuts time taken per iteration on most computers however it guarantees that search takes maximum number of iterations on average adding one iteration to search because comparison loop is performed only times in worst case slight increase in efficiency per iteration does not compensate for extra iteration for all but very large running time and cache use in analyzing performance of binary search another consideration is time required to compare two elements for integers and strings time required increases linearly as encoding length usually number of bits of elements increase for example comparing a pair of 64 bit unsigned integers would require comparing up to double bits as comparing a pair of 32 bit unsigned integers worst case is achieved when integers are equal this can be significant when encoding lengths of elements are large such as with large integer types or long strings which makes comparing elements expensive furthermore comparing floating point values most common digital representation of real numbers is often more expensive than comparing integers or short strings on most computer architectures processor has a hardware cache separate from ram since they are located within processor itself caches are much faster to access but usually store much less data than ram therefore most processors store memory locations that have been accessed recently along with memory locations close to it for example when an array element is accessed element itself may be stored along with elements that are stored close to it in ram making it faster to sequentially access array elements that are close in index to each other locality of reference on a sorted array binary search can jump to distant memory locations if array is large unlike algorithms such as linear search and linear probing in hash tables which access elements in sequence this adds slightly to running time of binary search for large arrays on most systems binary search versus other schemes sorted arrays with binary search are a very inefficient solution when insertion and deletion operations are interleaved with retrieval taking time for each such operation in addition sorted arrays can complicate memory use especially when elements are often inserted into array there are other data structures that support much more efficient insertion and deletion binary search can be used to perform exact matching and set membership determining whether a target value is in a collection of values there are data structures that support faster exact matching and set membership however unlike many other searching schemes binary search can be used for efficient approximate matching usually performing such matches in time regardless of type or structure of values themselves in addition there are some operations like finding smallest and largest element that can be performed efficiently on a sorted array linear search linear search is a simple search algorithm that checks every record until it finds target value linear search can be done on a linked list which allows for faster insertion and deletion than an array binary search is faster than linear search for sorted arrays except if array is short although array needs to be sorted beforehand all sorting algorithms based on comparing elements such as quicksort and merge sort require at least comparisons in worst case unlike linear search binary search can be used for efficient approximate matching there are operations such as finding smallest and largest element that can be done efficiently on a sorted array but not on an unsorted array trees thumb upright 1 25 binary search trees are searched using an algorithm similar to binary search a binary search tree is a binary tree data structure that works based on principle of binary search records of tree are arranged in sorted order and each record in tree can be searched using an algorithm similar to binary search taking on average logarithmic time insertion and deletion also require on average logarithmic time in binary search trees this can be faster than linear time insertion and deletion of sorted arrays and binary trees retain ability to perform all operations possible on a sorted array including range and approximate queries however binary search is usually more efficient for searching as binary search trees will most likely be imperfectly balanced resulting in slightly worse performance than binary search this even applies to balanced binary search trees binary search trees that balance their own nodes because they rarely produce tree with fewest possible levels except for balanced binary search trees tree may be severely imbalanced with few internal nodes with two children resulting in average and worst case search time approaching comparisons binary search trees take more space than sorted arrays binary search trees lend themselves to fast searching in external memory stored in hard disks as binary search trees can be efficiently structured in filesystems b tree generalizes this method of tree organization b trees are frequently used to organize long term storage such as databases and filesystems hashing for implementing associative arrays hash tables a data structure that maps keys to records using a hash function are generally faster than binary search on a sorted array of records most hash table implementations require only amortized constant time on average however hashing is not useful for approximate matches such as computing next smallest next largest and nearest key as only information given on a failed search is that target is not present in any record binary search is ideal for such matches performing them in logarithmic time binary search also supports approximate matches some operations like finding smallest and largest element can be done efficiently on sorted arrays but not on hash tables set membership algorithms a related problem to search is set membership any algorithm that does lookup like binary search can also be used for set membership there are other algorithms that are more specifically suited for set membership a bit array is simplest useful when range of keys is limited it compactly stores a collection of bits with each bit representing a single key within range of keys bit arrays are very fast requiring only time type of judy array handles 64 bit keys efficiently for approximate results bloom filters another probabilistic data structure based on hashing store a set of keys by encoding keys using a bit array and multiple hash functions bloom filters are much more space efficient than bit arrays in most cases and not much slower with hash functions membership queries require only time however bloom filters suffer from false positives other data structures there exist data structures that may improve on binary search in some cases for both searching and other operations available for sorted arrays for example searches approximate matches and operations available to sorted arrays can be performed more efficiently than binary search on specialized data structures such as van boas trees fusion trees tries and bit arrays these specialized data structures are usually only faster because they take advantage of properties of keys with a certain attribute usually keys that are small integers and thus will be time or space consuming for keys that lack that attribute as long as keys can be ordered these operations can always be done at least efficiently on a sorted array regardless of keys some structures such as judy arrays use a combination of approaches to mitigate this while retaining efficiency and ability to perform approximate matching variations uniform binary search thumb upright 1 4 uniform binary search stores difference between current and two next possible middle elements instead of specific bounds uniform binary search stores instead of lower and upper bounds difference in index of middle element from current iteration to next iteration a lookup table containing differences is computed beforehand for example if array to be searched is middle element would be in this case middle element of left subarray is and middle element of right subarray is uniform binary search would store value of as both indices differ from by this same amount to reduce search space algorithm either adds or subtracts this change from index of middle element uniform binary search may be faster on systems where it is inefficient to calculate midpoint such as on decimal computers exponential search thumb upright 1 6 visualization of exponential searching finding upper bound for subsequent binary search exponential search extends binary search to unbounded lists it starts by finding first element with an index that is both a power of two and greater than target value afterwards it sets that index as upper bound and switches to binary search a search takes iterations before binary search is started and at most iterations of binary search where is position of target value exponential search works on bounded lists but becomes an improvement over binary search only if target value lies near beginning of array interpolation search thumb upright 1 6 visualization of interpolation search in this case no searching is needed because estimate of target s location within array is correct other implementations may specify another function for estimating target s location instead of calculating midpoint interpolation search estimates position of target value taking into account lowest and highest elements in array as well as length of array it works on basis that midpoint is not best guess in many cases for example if target value is close to highest element in array it is likely to be located near end of array a common interpolation function is linear interpolation if is array are lower and upper bounds respectively and is target then target is estimated to be about of way between and when linear interpolation is used and distribution of array elements is uniform or near uniform interpolation search makes comparisons in practice interpolation search is slower than binary search for small arrays as interpolation search requires extra computation its time complexity grows more slowly than binary search but this only compensates for extra computation for large arrays fractional cascading thumb upright 2 5 in fractional cascading each array has pointers to every second element of another array so only one binary search has to be performed to search all arrays fractional cascading is a technique that speeds up binary searches for same element in multiple sorted arrays searching each array separately requires time where is number of arrays fractional cascading reduces this to by storing specific information in each array about each element and its position in other arrays fractional cascading was originally developed to efficiently solve various computational geometry problems fractional cascading has been applied elsewhere such as in data mining and internet protocol routing generalization to graphs binary search has been generalized to work on certain types of graphs where target value is stored in a vertex instead of an array element binary search trees are one such generalization when a vertex node in tree is queried algorithm either learns that vertex is target or otherwise which target would be located in however this can be further generalized as follows given an undirected positively weighted graph and a target vertex algorithm learns upon querying a vertex that it is equal to target or it is given an incident edge that is on shortest path from queried vertex to target standard binary search algorithm is simply case where graph is a path similarly binary search trees are case where edges to left or right subtrees are given when queried vertex is unequal to target for all undirected positively weighted graphs there is an algorithm that finds target vertex in queries in worst case noisy binary search thumb upright 1 7 in noisy binary search there is a certain probability that a comparison is incorrect noisy binary search algorithms solve case where algorithm cannot reliably compare elements of array for each pair of elements there is a certain probability that algorithm makes wrong comparison noisy binary search can find correct position of target with a given probability that controls reliability of yielded position every noisy binary search procedure must make at least comparisons on average where is binary entropy function and is probability that procedure yields wrong position noisy binary search problem can be considered as a case of renyi ulam game a variant of twenty questions where answers may be wrong quantum binary search classical computers are bounded to worst case of exactly iterations when performing binary search quantum algorithms for binary search are still bounded to a proportion of queries representing iterations of classical procedure but constant factor is less than one providing for a lower time complexity on quantum computers any exact quantum binary search procedure that is a procedure that always yields correct result requires at least queries in worst case where is natural logarithm there is an exact quantum binary search procedure that runs in queries in worst case in comparison grover s algorithm is optimal quantum algorithm for searching an unordered list of elements and it requires queries history idea of sorting a list of items to allow for faster searching dates back to antiquity earliest known example was anu tablet from babylon dating back to tablet contained about 500 sexagesimal numbers and their sorted in lexicographical order which made searching for a specific entry easier in addition several lists of names that were sorted by their first letter were discovered on aegean islands a latin dictionary finished in 1286 ce was first work to describe rules for sorting words into alphabetical order as opposed to just first few letters in 1946 john made first mention of binary search as part of moore school lectures a seminal and foundational college course in computing in 1957 william wesley peterson published first method for interpolation search every published binary search algorithm worked only for arrays whose length is one less than a power of two until 1960 when derrick henry published a binary search algorithm that worked on all arrays in 1962 hermann bottenbruch presented an algol 60 implementation of binary search that placed comparison for equality at end increasing average number of iterations by one but reducing to one number of comparisons per iteration uniform binary search was developed by a k chandra of stanford university in 1971 in 1986 bernard chazelle and leonidas j introduced fractional cascading as a method to solve numerous search problems in computational geometry implementation issues although basic idea of binary search is comparatively straightforward details can be surprisingly tricky donald knuth when jon bentley assigned binary search as a problem in a course for professional programmers he found that ninety percent failed to provide a correct solution after several hours of working on it mainly because incorrect implementations failed to run or returned a wrong answer in rare edge cases a study published in 1988 shows that accurate code for it is only found in five out of twenty textbooks furthermore bentley s own implementation of binary search published in his 1986 book programming pearls contained an overflow error that remained undetected for over twenty years java programming language library implementation of binary search had same overflow bug for more than nine years in a practical implementation variables used to represent indices will often be of fixed size and this can result in an arithmetic overflow for very large arrays if midpoint of span is calculated as then value of may exceed range of integers of data type used to store midpoint even if and are within range if and are nonnegative this can be avoided by calculating midpoint as an infinite loop may occur if exit conditions for loop are not defined correctly once exceeds search has failed and must convey failure of search in addition loop must be exited when target element is found or in case of an implementation where this check is moved to end checks for whether search was successful or failed at end must be in place bentley found that most of programmers who incorrectly implemented binary search made an error in defining exit conditions library support many languages standard libraries include binary search routines c provides function bsearch in its standard library which is typically implemented via binary search although official standard does not require it so c s standard template library provides functions binary search lower bound upper bound and equal range cobol provides search all verb for performing binary searches on cobol ordered tables go s sort standard library package contains functions search and which implement general binary search as well as specific implementations for searching slices of integers floating point numbers and strings respectively java offers a set of overloaded binarysearch static methods in classes and in standard java package for performing binary searches on java arrays and on lists respectively microsoft s net framework 2 0 offers static generic versions of binary search algorithm in its collection base classes an example would be system array s method binarysearch t t array t value for objective c cocoa framework provides options method in mac os x 10 6 apple s core foundation c framework also contains a function python provides bisect module ruby s array class includes a bsearch method with built in approximate matching see also same idea used to solve equations in real numbers binary search variation with simplified midpoint calculation notes and references notes citations works external links nist dictionary of algorithms and data structures binary search comparisons and benchmarks of a variety of binary search implementations in c index category search algorithms category 2 number