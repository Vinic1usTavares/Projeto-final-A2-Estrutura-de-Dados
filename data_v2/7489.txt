cobol an acronym for common business oriented language is a compiled english like computer programming language designed for business use it is imperative procedural and since 2002 object oriented cobol is primarily used in business finance and administrative systems for companies and governments cobol is still widely used in legacy applications deployed on mainframe computers such as large scale batch and transaction processing jobs but due to its declining popularity and retirement of experienced cobol programmers programs are being migrated to new platforms rewritten in modern languages or replaced with software packages most programming in cobol is now purely to maintain existing applications cobol was designed in 1959 by codasyl and was partly based on previous programming language design work by grace hopper commonly referred to as grand mother of cobol it was created as part of a us department of defense effort to create a portable programming language for data processing it was originally seen as a stopgap but department of defense promptly forced computer manufacturers to provide it resulting in its widespread adoption it was standardized in 1968 and has since been revised four times expansions include support for structured and object oriented programming current standard is iso iec 1989 2014 cobol statements have an english like syntax which was designed to be self documenting and highly readable however it is verbose and uses over 300 reserved words in contrast with modern succinct syntax like cobol has a more english like syntax in this case cobol code is split into four divisions identification environment data and procedure containing a rigid hierarchy of sections paragraphs and sentences lacking a large standard library standard specifies 43 statements 87 functions and just one class academic computer scientists were generally uninterested in business applications when cobol was created and were not involved in its design it was effectively designed from ground up as a computer language for business with an emphasis on inputs and outputs whose only data types were numbers and strings of text cobol has been criticized throughout its life for its verbosity design process and poor support for structured programming these weaknesses result in monolithic and though intended to be english like not easily comprehensible and verbose programs history and specification background in late 1950s computer users and manufacturers were becoming concerned about rising cost of programming a 1959 survey had found that in any data processing installation programming cost us 800 000 on average and that translating programs to run on new hardware would cost 600 000 at a time when new programming languages were proliferating at an ever increasing rate same survey suggested that if a common business oriented language were used conversion would be far cheaper and faster thumb alt caption grace hopper inventor of flow matic a predecessor to cobol on 8 april 1959 mary k hawes a computer scientist at burroughs corporation called a meeting of representatives from academia computer users and manufacturers at university of pennsylvania to organize a formal meeting on common business languages representatives included grace hopper inventor of english like data processing language flow matic jean sammet and saul gorn at april meeting group asked department of defense dod to sponsor an effort to create a common business language delegation impressed charles a phillips director of data system research staff at dod who thought that they thoroughly understood dod s problems dod operated 225 computers had a further 175 on order and had spent over 200 million on implementing programs to run on them portable programs would save time reduce costs and ease modernization phillips agreed to sponsor meeting and tasked delegation with drafting agenda cobol 60 on 28 and 29 may 1959 exactly one year after zurich algol 58 meeting a meeting was held at pentagon to discuss creation of a common programming language for business it was attended by 41 people and was chaired by phillips department of defense was concerned about whether it could run same data processing programs on different computers fortran only mainstream language at time lacked features needed to write such programs representatives enthusiastically described a language that could work in a wide variety of environments from banking and insurance to utilities and inventory control they agreed unanimously that more people should be able to program and that new language should not be restricted by limitations of contemporary technology a majority agreed that language should make maximal use of english be capable of change be machine independent and be easy to use even at expense of power meeting resulted in creation of a steering committee and short intermediate and long range committees short range committee was given to september three months to produce specifications for an interim language which would then be improved upon by other committees their official mission however was to identify strengths and weaknesses of existing programming languages and did not explicitly direct them to create a new language deadline was met with disbelief by short range committee one member betty described three month deadline as gross optimism and doubted that language really would be a stopgap steering committee met on 4 june and agreed to name entire activity as committee on data systems languages or codasyl and to form an executive committee short range committee was made up of members representing six computer manufacturers and three government agencies six computer manufacturers were burroughs corporation ibm minneapolis honeywell honeywell labs rca sperry rand and sylvania electric products three government agencies were us air force navy s david taylor model basin and national bureau of standards now national institute of standards and technology committee was chaired by joseph wegstein of us national bureau of standards work began by investigating data description statements existing applications and user experiences committee mainly examined flow matic aimaco and comtran programming languages flow matic language was particularly influential because it had been implemented and because aimaco was a derivative of it with only minor changes flow matic s inventor grace hopper also served as a technical adviser to committee flow matic s major contributions to cobol were long variable names english words for commands and separation of data descriptions and instructions ibm s comtran language invented by bob bemer was regarded as a competitor to flow matic by a short range committee made up of colleagues of grace hopper some of its features were not incorporated into cobol so that it would not look like ibm had dominated design process and jean sammet said in 1981 that there had been a strong anti ibm bias from some committee members herself included in one case after roy goldfinger author of comtran manual and intermediate range committee member attended a subcommittee meeting to support his language and encourage use of algebraic expressions grace hopper sent a memo to short range committee reiterating sperry rand s efforts to create a language based on english in 1980 grace hopper commented that cobol 60 is 95 flow matic and that comtran had had an extremely small influence furthermore she said that she would claim that work was influenced by both flow matic and comtran only to keep other people happy so they wouldn t try to knock us out features from comtran incorporated into cobol included formulas clause an improved if statement which obviated need for go tos and a more robust file management system usefulness of committee s work was subject of great debate while some members thought language had too many compromises and was result of design by committee others felt it was better than three languages examined some felt language was too complex others too simple controversial features included those some considered useless or too advanced for data processing users such features included boolean expressions formulas and table indices another point of controversy was whether to make keywords context sensitive and effect that would have on readability although context sensitive keywords were rejected approach was later used in pl i and partially in cobol from 2002 little consideration was given to interactivity interaction with operating systems few existed at that time and functions thought of as purely mathematical and of no use in data processing specifications were presented to executive committee on 4 september they fell short of expectations joseph wegstein noted that it contains rough spots and requires some additions and bob bemer later described them as a hodgepodge subcommittee was given until december to improve it at a mid september meeting committee discussed new language s name suggestions included busy business system information system language and common computer systems language name cobol was suggested by bob bemer in october intermediate range committee received copies of fact language specification created by roy nutt its features impressed committee so much that they passed a resolution to base cobol on it this was a blow to short range committee who had made good progress on specification despite being technically superior fact had not been created with portability in mind or through manufacturer and user consensus it also lacked a demonstrable implementation allowing supporters of a flow matic based cobol to overturn resolution rca representative howard bromberg also blocked fact so that rca s work on a cobol implementation would not go to waste it soon became apparent that committee was too large for any further progress to be made quickly a frustrated howard bromberg bought a 15 tombstone with cobol engraved on it and sent it to charles phillips to demonstrate his displeasure a sub committee was formed to analyze existing languages and was made up of six individuals william selden and gertrude tierney of ibm howard bromberg and howard discount of rca vernon reeves and jean e sammet of sylvania electric products sub committee did most of work creating specification leaving short range committee to review and modify their work before producing finished specification specifications were approved by executive committee on 8 january 1960 and sent to government printing office which printed these as cobol 60 language s stated objectives were to allow efficient portable programs to be easily written to allow users to move to new systems with minimal effort and cost and to be suitable for inexperienced programmers codasyl executive committee later created cobol maintenance committee to answer questions from users and vendors and to improve and expand specifications during 1960 list of manufacturers planning to build cobol compilers grew by september five more manufacturers had joined codasyl bendix control data corporation general electric ge national cash register and and all represented manufacturers had announced cobol compilers ge and ibm planned to integrate cobol into their own languages and comtran respectively in contrast international computers and planned to replace their language with cobol meanwhile rca and sperry rand worked on creating cobol compilers first cobol program ran on 17 august on an rca 501 on 6 and 7 december same cobol program albeit with minor changes ran on an rca computer and a remington rand computer demonstrating that compatibility could be achieved relative influences of which languages were used continues to this day in recommended advisory printed in all cobol reference manuals cobol 61 to cobol 65 many logical flaws were found in cobol 60 leading ge s charles katz to warn that it could not be interpreted unambiguously a reluctant short term committee enacted a total cleanup and by march 1963 it was reported that cobol s syntax was as definable as algol s although semantic ambiguities remained early cobol compilers were primitive and slow a 1962 us navy evaluation found compilation speeds of 3 11 statements per minute by mid 1964 they had increased to 11 1000 statements per minute it was observed that increasing memory would drastically increase speed and that compilation costs varied wildly costs per statement were between 0 23 and 18 91 in late 1962 ibm announced that cobol would be their primary development language and that development of comtran would cease cobol specification was revised three times in five years after its publication cobol 60 was replaced in 1961 by cobol 61 this was then replaced by cobol 61 extended specifications in 1963 which introduced sort and report writer facilities added facilities corrected flaws identified by honeywell in late 1959 in a letter to short range committee cobol edition 1965 brought further clarifications to specifications and introduced facilities for handling mass storage files and tables cobol 68 efforts began to standardize cobol to overcome incompatibilities between versions in late 1962 both iso and united states of america standards institute now ansi formed groups to create standards ansi produced usa standard cobol 23 in august 1968 which became cornerstone for later versions this version was known as american national standard ans cobol and was adopted by iso in 1972 cobol 74 by 1970 cobol had become most widely used programming language in world independently of ansi committee codasyl programming language committee was working on improving language they described new versions in 1968 1969 1970 and 1973 including changes such as new inter program communication debugging and file merging facilities as well as improved string handling and library inclusion features although codasyl was independent of ansi committee codasyl journal of development was used by ansi to identify features that were popular enough to warrant implementing programming language committee also liaised with and japanese cobol standard committee programming language committee was not well known however vice president william complained that two thirds of cobol community did not know of committee s existence it was also poor lacking funds to make public documents such as minutes of meetings and change proposals freely available in 1974 ansi published a revised version of ans cobol containing new features such as file organizations statement and segmentation module deleted features included statement statement which was replaced by and defined random access module which was superseded by new sequential and relative i o modules these made up 44 changes which rendered existing statements incompatible with new standard report writer was slated to be removed from cobol but was reinstated before standard was published iso later adopted updated standard in 1978 cobol 85 in june 1978 work began on revising cobol 74 proposed standard commonly called cobol 80 differed significantly from previous one causing concerns about incompatibility and conversion costs in january 1981 joseph t brophy senior vice president of travelers insurance threatened to sue standard committee because it was not upwards compatible with cobol 74 mr brophy described previous conversions of their 40 million line code base as non productive and a complete waste of our programmer resources later that year data processing management association dpma said it was strongly opposed to new standard citing prohibitive conversion costs and enhancements that were forced on user during first public review period committee received 2 200 responses of which 1 700 were negative form letters other responses were detailed analyses of effect cobol 80 would have on their systems conversion costs were predicted to be at least 50 cents per line of code fewer than a dozen of responses were in favor of proposed standard iso installed in 1979 international cobol experts group on initiative of wim group consisted of cobol experts from many countries including usa its goal was to achieve mutual understanding and respect between ansi and rest of world with regard to need of new cobol features after three years iso changed status of group to a formal working group cobol group took primary ownership and development of cobol standard where ansi did most of proposals in 1983 dpma withdrew its opposition to standard citing responsiveness of committee to public concerns in same year a national bureau of standards study concluded that proposed standard would present few problems a year later a cobol 80 compiler was released to dec vax users who noted that conversion of cobol 74 programs posed few problems new evaluate statement and inline perform were particularly well received and improved productivity thanks to simplified control flow and debugging second public review drew another 1 000 mainly negative responses while last drew just 25 by which time many concerns had been addressed in 1985 iso working group 4 accepted then version of ansi proposed standard made several changes and set it as new iso standard cobol 85 it was published in late 1985 sixty features were changed or deprecated and many were added such as scope terminators end if end perform end read etc nested subprograms continue a no operation statement evaluate a switch statement initialize a statement that can set groups of data to their default values inline perform loop bodies previously loop bodies had to be specified in a separate procedure reference modification which allows access to substrings i o status codes new standard was adopted by all national standard bodies including ansi two amendments followed in 1989 and 1993 first introducing intrinsic functions and other providing corrections cobol 2002 and object oriented cobol in 1997 gartner group estimated that there were a total of 200 billion lines of cobol in existence which ran 80 of all business programs in early 1990s work began on adding object orientation in next full revision of cobol object oriented features were taken from c and initial estimate was to have this revision completed by 1997 and an iso committee draft cd was available by 1997 some vendors including micro focus fujitsu and ibm introduced object oriented syntax based on drafts of full revision final approved iso standard was approved and published in late 2002 fujitsu micro focus and introduced object oriented cobol compilers targeting net framework there were many other new features many of which had been in codasyl cobol journal of development since 1978 and had missed opportunity to be included in cobol 85 these other features included free form code user defined functions recursion locale based processing support for extended character sets such as unicode floating point and binary data types until then binary items were truncated based on their declaration s base 10 specification portable arithmetic results bit and boolean data types pointers and syntax for getting and freeing storage for text based user interfaces facility improved interoperability with other programming languages and framework environments such as net and java three corrigenda were published for standard two in 2006 and one in 2009 cobol 2014 between 2003 and 2009 three technical reports were produced describing object finalization xml processing and collection classes for cobol cobol 2002 suffered from poor support no compilers completely supported standard micro focus found that it was due to a lack of user demand for new features and due to abolition of nist test suite which had been used to test compiler conformance standardization process was also found to be slow and under resourced cobol 2014 includes following changes portable arithmetic results have been replaced by ieee 754 data types major features have been made optional such as validate facility report writer and screen handling facility method overloading dynamic capacity tables a feature dropped from draft of cobol 2002 legacy cobol programs are used globally in governments and businesses and are running on diverse operating systems such as z os z vse unix openvms and windows in 1997 gartner group reported that 80 of world s business ran on cobol with over 200 billion lines of code and 5 billion lines more being written annually near end of 20th century year 2000 problem y2k was focus of significant cobol programming effort sometimes by same programmers who had designed systems decades before particular level of effort required to correct cobol code has been attributed to large amount of business oriented cobol as business applications use dates heavily and to fixed length data fields after clean up effort put into these programs for y2k a 2003 survey found that many remained in use authors said that survey data suggest a gradual decline in importance of cobol in application development over following 10 years unless integration with other languages and technologies can be adopted in 2006 and 2012 computerworld surveys found that over 60 of organizations used cobol more than c and visual basic net and that for half of those cobol was used for majority of their internal software 36 of managers said they planned to migrate from cobol and 25 said they would like to if it was cheaper instead some businesses have migrated their systems from expensive mainframes to cheaper more modern systems while maintaining their cobol programs testimony before house of representatives in 2016 indicated that cobol is still in use by many federal agencies features syntax cobol has an english like syntax which is used to describe nearly everything in a program for example a condition can be expressed as or more concisely as or more complex conditions can be abbreviated by removing repeated conditions and variables for example can be shortened to as a consequence of this english like syntax cobol has over 300 keywords some of keywords are simple alternative or spellings of same word which provides for more english like statements and clauses e g and keywords can be used interchangeably as can and and and each cobol program is made up of four basic lexical items words literals picture character strings see and separators words include reserved words and user defined identifiers they are up to 31 characters long and may include letters digits and underscores literals include numerals e g and strings e g separators include space character and commas and semi colons followed by a space a cobol program is split into four divisions identification division environment division data division and procedure division identification division specifies name and type of source element and is where classes and interfaces are specified environment division specifies any program features that depend on system running it such as files and character sets data division is used to declare variables and parameters procedure division contains program s statements each division is sub divided into sections which are made up of paragraphs metalanguage cobol s syntax is usually described with a unique metalanguage using braces brackets bars and underlining metalanguage was developed for original cobol specifications although backus naur form did exist at time committee had not heard of it elements of cobol s metalanguage element appearance function all capitals example reserved word underlining reserved word is compulsory braces only one option may be selected brackets zero or one options may be selected ellipsis preceding element may be repeated bars one or more options may be selected any option may only be selected once zero or more options may be selected any option may only be selected once as an example consider following description of an add statement this description permits following variants add 1 to x add 1 a b to x rounded y z rounded add a b to c on size error display error end add add a to b not size error display no error on size error display error code format cobol can be written in two formats fixed default or free in fixed format code must be aligned to fit in certain areas a hold over from using punched cards until cobol 2002 these were name column s usage sequence number area 1 6 originally used for card line numbers this area is ignored by compiler indicator area 7 following characters are allowed here comment line comment line that will be printed on a new page of a source listing continuation line where words or literals from previous line are continued d line enabled in debugging mode which is otherwise ignored area a 8 11 this contains division section and procedure headers 01 and 77 level numbers and file report descriptors area b 12 72 any other code not allowed in area a program name area 73 historically up to column 80 for punched cards it is used to identify program or sequence card belongs to in cobol 2002 areas a and b were merged to form program text area which now ends at an defined column cobol 2002 also introduced free format code free format code can be placed in any column of file as in newer programming languages comments are specified using which can be placed anywhere and can also be used in fixed format source code continuation lines are not present and page directive replaces indicator identification division identification division identifies following code entity and contains definition of a class or interface object oriented programming classes and interfaces have been in cobol since 2002 classes have factory objects containing class methods and variables and instance objects containing instance methods and variables inheritance and interfaces provide polymorphism support for generic programming is provided through parameterized classes which can be instantiated to use any class or interface objects are stored as references which may be restricted to a certain type there are two ways of calling a method statement which acts similarly to or through inline method invocation which is analogous to using functions these are equivalent invoke my class foo returning var move my class foo to var inline method invocation cobol does not provide a way to hide methods class data can be hidden however by declaring it without a clause which leaves user with no way to access it method overloading was added in cobol 2014 environment division environment division contains configuration section and input output section configuration section is used to specify variable features such as currency signs locales and character sets input output section contains file related information files cobol supports three file formats or sequential indexed and relative in sequential files records are contiguous and must be traversed sequentially similarly to a linked list indexed files have one or more indexes which allow records to be randomly accessed and which can be sorted on them each record must have a unique key but other record keys need not be unique implementations of indexed files vary between vendors although common implementations such as c isam and are based on ibm s isam relative files like indexed files have a unique record key but they do not have alternate keys a relative record s key is its ordinal position for example 10th record has a key of 10 this means that creating a record with a key of 5 may require creation of empty preceding records relative files also allow for both sequential and random access a common non standard extension is organization used to process text files records in a file are terminated by a and may be of varying length data division data division is split into six sections which declare different items file section for file records working storage section for static variables local storage section for automatic variables linkage section for parameters and return value report section and screen section for text based user interfaces aggregated data data items in cobol are declared hierarchically through use of level numbers which indicate if a data item is part of another an item with a higher level number is subordinate to an item with a lower one top level data items with a level number of 1 are called items that have subordinate aggregate data are called those that do not are called level numbers used to describe standard data items are between 1 and 49 01 some record aggregate group record item 05 num pic 9 10 elementary item 05 date aggregate sub group record item 10 year pic 9 4 elementary item 10 month pic 99 elementary item 10 day pic 99 elementary item in above example elementary item and group item are subordinate to record while elementary items and are part of group item subordinate items can be with or keyword for example consider example code above along with following example 01 sale date 05 year pic 9 4 05 month pic 99 05 day pic 99 names and are ambiguous by themselves since more than one data item is defined with those names to specify a particular data item for instance one of items contained within group programmer would use or equivalent this syntax is similar to dot notation supported by most contemporary languages other data levels a level number of 66 is used to declare a re grouping of previously defined items irrespective of how those items are structured this data level also referred to by associated is rarely used and circa 1988 was usually found in old programs its ability to ignore hierarchical and logical structure data meant its use was not recommended and many installations forbade its use 01 customer record 05 cust key pic x 10 05 cust name 10 cust first name pic x 30 10 cust last name pic x 30 05 cust dob pic 9 8 05 cust balance pic 9 7 66 cust personal details renames cust name thru cust dob 66 cust all details renames cust name thru cust balance a 77 level number indicates item is stand alone and in such situations is equivalent to level number 01 for example following code declares two 77 level data items and which are non group data items that are independent of not subordinate to any other data items 77 property name pic x 80 77 sales region pic 9 5 an 88 level number declares a a so called 88 level which is true when its parent data item contains one of values specified in its clause for example following code defines two 88 level condition name items that are true or false depending on current character data value of data item when data item contains a value of condition name is true whereas when it contains a value of or condition name is true if data item contains some other value both of condition names are false 01 wage type pic x 88 wage is hourly value h 88 wage is yearly value s y data types standard cobol provides following data types data type sample declaration notes alphabetic may only contain letters or spaces alphanumeric may contain any characters boolean data stored in form of 0s and 1s as a binary number index used to reference table elements national similar to alphanumeric but using an extended character set e g 8 numeric may contain only numbers object may reference either an object or null pointer type safety is variable in cobol numeric data is converted between different representations and sizes silently and alphanumeric data can be placed in any data item that can be stored as a string including numeric and group data in contrast object references and pointers may only be assigned from items of same type and their values may be restricted to a certain type picture clause a or clause is a string of characters each of which represents a portion of data item and what it may contain some picture characters specify type of item and how many characters or digits it occupies in memory for example a indicates a decimal digit and an indicates that item is signed other picture characters called and characters specify how an item should be formatted for example a series of characters define character positions as well as how a leading sign character is to be positioned within final character data rightmost non numeric character will contain item s sign while other character positions corresponding to a to left of this position will contain a space repeated characters can be specified more concisely by specifying a number in parentheses after a picture character for example is equivalent to picture specifications containing only digit and sign characters define purely data items while picture specifications containing alphabetic or alphanumeric characters define data items presence of other formatting characters define or data items examples clause value in value out this is legal but results in undefined behavior 10 note leading spaces 0 usage clause clause declares format data is stored in depending on data type it can either complement or be used instead of a clause while it can be used to declare pointers and object references it is mostly geared towards specifying numeric types these numeric formats are binary where a minimum size is either specified by picture clause or by a usage clause such as binary long where data may be stored in whatever format implementation provides often equivalent to default format where data is stored as a string floating point in either an implementation dependent format or according to ieee 754 where data is stored as a string using an extended character set where data is stored in smallest possible decimal format typically packed binary coded decimal report writer report writer is a declarative facility for creating reports programmer need only specify report layout and data required to produce it freeing them from having to write code to handle things like page breaks data formatting and headings and footings reports are associated with report files which are files which may only be written to through report writer statements fd report out report sales report each report is defined in report section of data division a report is split into report groups which define report s headings footings and details reports work around hierarchical control breaks occur when a key variable changes it value for example when creating a report detailing customers orders a control break could occur when program reaches a different customer s orders here is an example report description for a report which gives a salesperson s sales and which warns of any invalid records rd sales report page limits 60 lines first detail 3 controls seller name 01 type page heading 03 col 1 value sales report 03 col 74 value page 03 col 79 pic z9 source page counter 01 sales on day type detail line 1 03 col 3 value sales on 03 col 12 pic 99 99 9999 source sales date 03 col 21 value were 03 col 26 pic 9 99 source sales amount 01 invalid sales type detail line 1 03 col 3 value invalid record 03 col 19 pic x 34 source sales record 01 type control heading seller name line 2 03 col 1 value seller 03 col 9 pic x 30 source seller name above report description describes following layout sales report page 1 seller howard bromberg sales on 10 12 2008 were 1000 00 sales on 12 12 2008 were 0 00 sales on 13 12 2008 were 31 47 invalid record howard bromberg seller howard discount sales report page 12 sales on 08 05 2014 were 543 98 invalid record william selden sales on 30 05 2014 were 0 00 four statements control report writer which prepares report writer for printing which prints a report group which suppresses printing of a report group and which terminates report processing for above sales report example procedure division might look like this open input sales output report out initiate sales report perform until 1 1 read sales at end exit perform end read validate sales record if valid record generate sales on day else generate invalid sales end if end perform terminate sales report close sales report out use of report writer facility tended to vary considerably some organizations used it extensively and some not at all in addition implementations of report writer ranged in quality with those at lower end sometimes using excessive amounts of memory at runtime procedure division procedures sections and paragraphs in procedure division collectively called procedures can be used as labels and as simple subroutines unlike in other divisions paragraphs do not need to be in sections execution goes down through procedures of a program until it is terminated to use procedures as subroutines verb is used a statement somewhat resembles a procedure call in a modern language in sense that execution returns to code following statement at end of called code however it does not provide any mechanism for parameter passing or for returning a result value if a subroutine is invoked using a simple statement like then control returns at end of called procedure however is unusual in that it may be used to call a range spanning a sequence of several adjacent procedures this is done with construct procedure so and so perform alpha perform alpha thru gamma stop run alpha display a beta display b gamma display c output of this program will be a a b c also differs from conventional procedure calls in that there is at least traditionally no notion of a call stack as a consequence nested invocations are possible a sequence of code being ed may execute a statement itself but require extra care if parts of same code are executed by both invocations problem arises when code in inner invocation reaches exit point of outer invocation more formally if control passes through exit point of a invocation that was called earlier but has not completed yet cobol 2002 standard officially stipulates that behaviour is undefined reason is that cobol rather than a return address operates with what may be called a continuation address when control flow reaches end of any procedure continuation address is looked up and control is transferred to that address before program runs continuation address for every procedure is to start address of procedure that comes next in program text so that if no statements happen control flows from top to bottom through program but when a statement executes it modifies continuation address of called procedure or last procedure of called range if was used so that control will return to call site at end original value is saved and is restored afterwards but there is only one storage position if two nested invocations operate on overlapping code they may interfere which each other s management of continuation address in several ways following example taken from veerman verhoeven 2006 illustrates problem label1 display 1 perform label2 thru label3 stop run label2 display 2 perform label3 thru label4 label3 display 3 label4 display 4 one might expect that output of this program would be 1 2 3 4 3 after displaying 2 second causes 3 and 4 to be displayed and then first invocation continues on with 3 in traditional cobol implementations this is not case rather first statement sets continuation address at end of so that it will jump back to call site inside second statement sets return at end of but does not modify continuation address of expecting it to be default continuation thus when inner invocation arrives at end of it jumps back to outer statement and program stops having printed just 1 2 3 on other hand in some cobol implementations like open source compiler two statements do not interfere with each other and output is indeed 1 2 3 4 3 therefore behaviour in such cases is not only perhaps surprising it is also not portable a special consequence of this limitation is that cannot be used to write recursive code another simple example to illustrate this slightly simplified from veerman verhoeven 2006 move 1 to a perform label stop run label display a if a 3 add 1 to a perform label end if display end one might expect that output is 1 2 3 end end end and in fact that is what some cobol compilers will produce but some compilers like ibm cobol will produce code that prints 1 2 3 end end end end and so on printing end over and over in an endless loop since there is limited space to store backup continuation addresses backups get overwritten in course of recursive invocations and all that can be restored is jump back to statements cobol 2014 has 47 statements also called which can be grouped into following broad categories control flow i o data manipulation and report writer report writer statements are covered in report writer section control flow cobol s conditional statements are and is a switch like statement with added capability of evaluating multiple values and conditions this can be used to implement decision tables for example following might be used to control a cnc lathe evaluate true also desired speed also current speed when lid closed also min speed thru max speed also less than desired speed perform speed up machine when lid closed also min speed thru max speed also greater than desired speed perform slow down machine when lid open also any also not zero perform emergency stop when other continue end evaluate statement is used to define loops which are executed a condition is true not true which is more common in other languages it is also used to call procedures or ranges of procedures see procedures section for more details and call subprograms and methods respectively name of method is contained in a string which may be a literal or a data item parameters can be passed by reference by content where a copy is passed by reference or by value but only if a prototype is available unloads subprograms from memory causes program to jump to a specified procedure statement is a return statement and statement stops program statement has six different formats it can be used as a return statement a break statement a continue statement an end marker or to leave a procedure exceptions are raised by a statement and caught with a handler or defined in portion of procedure division are sections beginning with a statement which specify errors to handle exceptions can be names or objects is used in a declarative to jump to statement after one that raised exception or to a procedure outside unlike other languages exceptions may not terminate program and program can proceed unaffected i o file i o is handled by self describing and statements along with a further three which updates a record which selects subsequent records to access by finding a record with a certain key and which releases a lock on last record accessed user interaction is done using and data manipulation following verbs manipulate data which sets data items to their default values which assigns values to data items move corresponding assigns corresponding like named fields which has 15 formats it can modify indices assign object references and alter table capacities among other functions and which handle arithmetic with assigning result of a formula to a variable and which handle dynamic memory which validates and distributes data as specified in an item s description in data division and which concatenate and split strings respectively which tallies or replaces instances of specified substrings within a string which searches a table for first entry satisfying a condition files and tables are sorted using and verb merges and sorts files verb provides records to sort and retrieves sorted records in order scope termination some statements such as and may themselves contain statements such statements may be terminated in two ways by a period which terminates all statements contained or by a scope terminator which terminates nearest matching open statement terminator period implicit termination if invalid record if no more records next sentence else read record file at end set no more records to true scope terminators explicit termination if invalid record if no more records continue else read record file at end set no more records to true end read end if end if nested statements terminated with a period are a common source of bugs for example examine following code if x display y display z here intent is to display y and z if condition x is true however z will be displayed whatever value of x because if statement is terminated by an erroneous period after another bug is a result of dangling else problem when two if statements can associate with an else if x if y display a else display b in above fragment else associates with statement instead of statement causing a bug prior to introduction of explicit scope terminators preventing it would require to be placed after inner if self modifying code original 1959 cobol specification supported infamous statement for which many compilers generated self modifying code x and y are procedure labels and single statement in procedure x executed after such an statement means instead many compilers still support it examples of compiler support for can be seen in following but it was deemed obsolete in cobol 1985 standard and deleted in 2002 statement was poorly regarded because it undermined locality of context and made a program s overall logic difficult to comprehend as textbook author daniel d mccracken wrote in 1976 when someone who has never seen program before must become familiar with it as quickly as possible sometimes under critical time pressure because program has failed sight of a go to statement in a paragraph by itself signaling as it does existence of an unknown number of alter statements at unknown locations throughout program strikes fear in heart of bravest programmer hello world a hello world program in cobol identification division program id hello world procedure division display hello world when now famous hello world program example in c programming language was first published in 1978 a similar mainframe cobol program sample would have been submitted through jcl very likely using a punch card reader and 80 column punch cards listing below with an empty data division was tested using gnu linux and system 370 hercules emulator running mvs 3 jcl written in july 2015 is derived from hercules tutorials and samples hosted by jay moseley in keeping with cobol programming of that era hello world is displayed in all capital letters cobuclg job 001 cobol base test class a a 1 1 basetest exec cobuclg cob dd 00000 validation of base cobol install 01000 identification division program id hello environment division 02100 configuration section source computer object computer hercules special names console is consl data division procedure division 00 main display hello world upon consl stop run lked syslib dd dsname sys1 disp shr dd dsname sys1 disp shr go dd a after submitting jcl mvs console displayed 19 52 48 job 3 cobuclg on cobol base test 19 52 48 job 3 warning message s for job cobuclg issued 19 52 48 job 3 cobuclg started 1 class a sys 19 52 48 job 3 iec130i syspunch dd statement missing 19 52 48 job 3 iec130i syslib dd statement missing 19 52 48 job 3 iec130i syspunch dd statement missing 19 52 48 job 3 program 19 52 48 job 3 cobuclg basetest cob rc 0000 19 52 48 job 3 cobuclg basetest lked rc 0000 19 52 48 job 3 hello world 19 52 48 job 3 cobuclg basetest go pgm dd rc 0000 19 52 48 job 3 cobuclg ended line 10 of console listing above is highlighted for effect highlighting is not part of actual console output associated compiler listing generated over four pages of technical detail and job run information for single line of output from 14 lines of cobol criticism and defense lack of structure in 1970s adoption of structured programming paradigm was becoming increasingly widespread edsger dijkstra a preeminent computer scientist wrote a letter to editor of communications of acm published 1975 entitled how do we tell truths that might hurt in which he was critical of cobol and several other contemporary languages remarking that use of cobol cripples mind in a published dissent to dijkstra s remarks computer scientist howard e tompkins claimed that unstructured cobol tended to be written by programmers that have never had benefit of structured cobol taught well arguing that issue was primarily one of training one cause of spaghetti code was statement attempts to remove s from cobol code however resulted in convoluted programs and reduced code quality s were largely replaced by statement and procedures which promoted modular programming and gave easy access to powerful looping facilities however could only be used with procedures so loop bodies were not located where they were used making programs harder to understand cobol programs were infamous for being monolithic and lacking cobol code could only be modularized through procedures which were found to be inadequate for large systems it was impossible to restrict access to data meaning a procedure could access and modify data item furthermore there was no way to pass parameters to a procedure an omission jean sammet regarded as committee s biggest mistake another complication stemmed from ability to a specified sequence of procedures this meant that control could jump to and return from any procedure creating convoluted control flow and permitting a programmer to break single entry single exit rule this situation improved as cobol adopted more features cobol 74 added subprograms giving programmers ability to control data each part of program could access cobol 85 then added nested subprograms allowing programmers to hide subprograms further control over data and code came in 2002 when object oriented programming user defined functions and user defined data types were included nevertheless much important legacy cobol software uses unstructured code which has become it can be too risky and costly to modify even a simple section of code since it may be used from unknown places in unknown ways compatibility issues cobol was intended to be a highly portable common language however by 2001 around 300 dialects had been created one source of dialects was standard itself 1974 standard was composed of one mandatory nucleus and eleven functional modules each containing two or three levels of support this permitted 104 976 official variants cobol 85 was not fully compatible with earlier versions and its development was controversial joseph t brophy cio of travelers insurance spearheaded an effort to inform cobol users of heavy reprogramming costs of implementing new standard as a result ansi cobol committee received more than 2 200 letters from public mostly negative requiring committee to make changes on other hand conversion to cobol 85 was thought to increase productivity in future years thus justifying conversion costs verbose syntax cobol syntax has often been criticized for its verbosity proponents say that this was intended to make code self documenting easing program maintenance cobol was also intended to be easy for programmers to learn and use while still being readable to non technical staff such as managers desire for readability led to use of english like syntax and structural elements such as nouns verbs clauses sentences sections and divisions yet by 1984 maintainers of cobol programs were struggling to deal with incomprehensible code and main changes in cobol 85 were there to help ease maintenance jean sammet a short range committee member noted that little attempt was made to cater to professional programmer in fact people whose main interest is programming tend to be very unhappy with cobol which she attributed to cobol s verbose syntax isolation from computer science community cobol community has always been isolated from computer science community no academic computer scientists participated in design of cobol all of those on committee came from commerce or government computer scientists at time were more interested in fields like numerical analysis physics and system programming than commercial file processing problems which cobol development tackled jean sammet attributed cobol s unpopularity to an initial snob reaction due to its lack of influential computer scientists participating in design process and a disdain for business data processing cobol specification used a unique notation or metalanguage to define its syntax rather than new backus naur form which committee did not know of this resulted in severe criticism later cobol suffered from a shortage of material covering it it took until 1963 for introductory books to appear with richard d irwin publishing a college textbook on cobol in 1966 by 1985 there were twice as many books on fortran and four times as many on basic as on cobol in library of congress university professors taught more modern state of art languages and techniques instead of cobol which was said to have a trade school nature donald nelson chair of codasyl cobol committee said in 1984 that academics hate cobol and that computer science graduates had hate cobol drilled into them a 2013 poll by micro focus found that 20 of university academics thought cobol was outdated or dead and that 55 believed their students thought cobol was outdated or dead same poll also found that only 25 of academics had cobol programming on their curriculum even though 60 thought they should teach it in contrast in 2003 cobol featured in 80 of information systems curricula in united states same proportion as c and java there was also significant condescension towards cobol in business community from users of other languages for example fortran or assembler implying that cobol could be used only for non challenging problems concerns about design process doubts have been raised about competence of standards committee short term committee member howard bromberg said that there was little control over development process and that it was plagued by discontinuity of personnel and a lack of talent jean sammet and jerome garfunkel also noted that changes introduced in one revision of standard would be reverted in next due as much to changes in who was in standard committee as to objective evidence cobol standards have repeatedly suffered from delays cobol 85 arrived five years later than hoped cobol 2002 was five years late and cobol 2014 was six years late to combat delays standard committee allowed creation of optional addenda which would add features more quickly than by waiting for next standard revision however some committee members raised concerns about incompatibilities between implementations and frequent modifications of standard influences on other languages cobol s data structures influenced subsequent programming languages its record and file structure influenced pl i and pascal and redefines clause was a predecessor to pascal s variant records explicit file structure definitions preceded development of database management systems and aggregated data was a significant advance over fortran s arrays picture data declarations were incorporated into pl i with minor changes cobol s facility although considered primitive influenced development of include directives focus on portability and standardization meant programs written in cobol could be portable and facilitated spread of language to a wide variety of hardware platforms and operating systems this can be seen in additionally well defined division structure restricts definition of external references to environment division which simplifies platform changes in particular see also alphabetical list of programming languages cobol cobol resource codasyl comparison of programming languages notes references citations sources external links category net programming languages category 1959 software category class based programming languages category computer related introductions in 1959 category cross platform software category object oriented programming languages category procedural programming languages category programming languages created by women category programming languages created in 1959 category programming languages with an iso standard category statically typed programming languages category structured programming languages