in c computer programming allocators are a component of c standard library standard library provides several data structures such as list and set commonly referred to as containers a common trait among these containers is their ability to change size during execution of program to achieve this some form of dynamic memory allocation is usually required allocators handle all requests for allocation and deallocation of memory for a given container c standard library provides general purpose allocators that are used by default however custom allocators may also be supplied by programmer allocators were invented by alexander stepanov as part of standard template library stl they were originally intended as a means to make library more flexible and independent of underlying memory model allowing programmers to utilize custom pointer and reference types with library however in process of adopting stl into c standard c standardization committee realized that a complete abstraction of memory model would incur unacceptable performance penalties to remedy this requirements of allocators were made more restrictive as a result level of customization provided by allocators is more limited than was originally envisioned by stepanov nevertheless there are many scenarios where customized allocators are desirable some of most common reasons for writing custom allocators include improving performance of allocations by using memory pools and encapsulating access to different types of memory like shared memory or garbage collected memory in particular programs with many frequent allocations of small amounts of memory may benefit greatly from specialized allocators both in terms of running time and memory footprint background alexander stepanov and meng lee presented standard template library to c standards committee in march 1994 library received preliminary approval although a few issues were raised in particular stepanov was requested to make library containers independent of underlying memory model which led to creation of allocators consequently all of stl container interfaces had to be rewritten to accept allocators in adapting stl to be included in c standard library stepanov worked closely with several members of standards committee including andrew koenig and bjarne stroustrup who observed that custom allocators could potentially be used to implement persistent storage stl containers which stepanov at time considered an important and interesting insight from point of view of portability all machine specific things which relate to notion of address pointer and so on are encapsulated within a tiny well understood mechanism alex stepanov designer of standard template library original allocator proposal incorporated some language features that had not yet been accepted by committee namely ability to use template arguments that are themselves templates since these features could not be compiled by any existing compiler there was according to stepanov an enormous demand on bjarne stroustrup s and andy koenig s time trying to verify that we were using these non implemented features correctly where library had previously used pointer and reference types directly it would now only refer to types defined by allocator stepanov later described allocators as follows a nice feature of stl is that only place that mentions machine related types is encapsulated within roughly 16 lines of code while stepanov had originally intended allocators to completely encapsulate memory model standards committee realized that this approach would lead to unacceptable efficiency degradations to remedy this additional wording was added to allocator requirements in particular container implementations may assume that allocator s type definitions for pointers and related integral types are equivalent to those provided by default allocator and that all instances of a given allocator type always compare equal effectively contradicting original design goals for allocators and limiting usefulness of allocators that carry state stepanov later commented that while allocators are not such a bad idea in theory u nfortunately they cannot work in practice he observed that to make allocators really useful a change to core language with regards to references was necessary 2011 revision of c standard removed weasel words requiring that allocators of a given type always compare equal and use normal pointers these changes make stateful allocators much more useful and allow allocators to manage out of process shared memory current purpose of allocators is to give programmer control over memory allocation within containers rather than to adapt address model of underlying hardware in fact revised standard eliminated ability of allocators to represent extensions to c address model formally and deliberately eliminating their original purpose requirements any class that fulfills allocator requirements can be used as an allocator in particular a class a capable of allocating memory for an object of type t must provide types a pointer a const pointer a reference a const reference and a value type for generically declaring objects and references or pointers to objects of type t it should also provide type a size type an unsigned type which can represent largest size for an object in allocation model defined by a and similarly a signed integral a difference type that can represent difference between any two pointers in allocation model although a conforming standard library implementation is allowed to assume that allocator s a pointer and a const pointer are simply for t and t const library implementors are encouraged to support more general allocators an allocator a for objects of type t must have a member function with signature a pointer a allocate size type n a void const pointer hint 0 this function returns a pointer to first element of a newly allocated array large enough to contain n objects of type t only memory is allocated and objects are not constructed moreover an optional pointer argument that points to an object already allocated by a can be used as a hint to implementation about where new memory should be allocated in order to improve locality however implementation is free to ignore argument corresponding void a deallocate a pointer p a size type n member function accepts any pointer that was returned from a previous invocation of a allocate member function and number of elements to deallocate but not destruct a max size member function returns largest number of objects of type t that could be expected to be successfully allocated by an invocation of a allocate value returned is typically a size type 1 t also a address member function returns an a pointer denoting address of an object given an a reference object construction and destruction is performed separately from allocation and deallocation allocator is required to have two member functions a construct and a destroy both functions have been deprecated in c 17 and removed in c 20 which handles object construction and destruction respectively semantics of functions should be equivalent to following template typename t void a construct a pointer p a const reference t new void p t t template typename t void a destroy a pointer p t p t above code uses placement new syntax and calls directly allocators should be copy constructible an allocator for objects of type t can be constructed from an allocator for objects of type u if an allocator a allocates a region of memory r then r can only be deallocated by an allocator that compares equal to a allocators are required to supply a template class member template typename u a rebind a u other which enables possibility of obtaining a related allocator parameterized in terms of a different type for example given an allocator type intallocator for objects of type int a related allocator type for objects of type long could be obtained using intallocator rebind long other custom allocators one of main reasons for writing a custom allocator is performance utilizing a specialized custom allocator may substantially improve performance or memory usage or both of program default allocator uses operator new to allocate memory iso iec 2003 iso iec 2003 e programming languages c ss20 4 1 1 allocator members lib allocator members para 3 this is often implemented as a thin layer around c heap allocation functions which are usually optimized for infrequent allocation of large memory blocks this approach may work well with containers that mostly allocate large chunks of memory like vector and however for containers that require frequent allocations of small objects such as map and list using default allocator is generally slow other common problems with a malloc based allocator include poor locality of reference and excessive memory fragmentation a popular approach to improve performance is to create a memory pool based allocator instead of allocating memory every time an item is inserted or removed from a container a large block of memory memory pool is allocated beforehand possibly at startup of program custom allocator will serve individual allocation requests by simply returning a pointer to memory from pool actual deallocation of memory can be deferred until lifetime of memory pool ends an example of memory pool based allocators can be found in boost c libraries another viable use of custom allocators is for debugging memory related errors this could be achieved by writing an allocator that allocates extra memory in which it places debugging information such an allocator could be used to ensure that memory is allocated and deallocated by same type of allocator and also provide limited protection against overruns in short this paragraph is standard s i have a dream speech for allocators until that dream becomes common reality programmers concerned about portability will limit themselves to custom allocators with no state scott meyers effective stl subject of custom allocators has been treated by many c experts and authors including scott meyers in effective stl and andrei in modern c design meyers emphasises that c 98 requires all instances of an allocator to be equivalent and notes that this in effect forces portable allocators to not have state although c 98 standard did encourage library implementors to support stateful allocators meyers calls relevant paragraph a lovely sentiment that offers you next to nothing characterizing restriction as draconian in c programming language bjarne stroustrup on other hand argues that apparently d restriction against per object information in allocators is not particularly serious pointing out that most allocators do not need state and have better performance without it he mentions three use cases for custom allocators namely memory pool allocators shared memory allocators and garbage collected memory allocators he presents an allocator implementation that uses an internal memory pool for fast allocation and deallocation of small chunks of memory but notes that such an optimization may already be performed by allocator provided by implementation usage when one of standard containers allocator is specified through a template argument which defaults to std allocator t namespace std template class t class allocator allocator t class vector like all c class templates instantiations of standard library containers with different allocator arguments are distinct types a function expecting an std vector int argument will therefore only accept a vector instantiated with default allocator enhancements to allocators in c 11 c 11 standard has enhanced allocator interface to allow scoped allocators so that containers with nested memory allocations such as vector of strings or a map of lists of sets of user defined types can ensure that all memory is sourced from container s allocator example gnu cxx new allocator typename class template reference https gcc gnu org gcc 4 9 0 libstdc api html processor 0 vendor id authenticamd cpu family 16 model 6 model name amd athlon tm ii x2 270 processor stepping 3 microcode 0x10000c8 cpu mhz 2000 000 cache size 1024 kb processor 1 vendor id authenticamd cpu family 16 model 6 model name amd athlon tm ii x2 270 processor stepping 3 microcode 0x10000c8 cpu mhz 800 000 cache size 1024 kb linux debian 3 14 2 686 pae 1 smp debian 3 14 15 2 2014 08 09 i686 gnu linux gcc debian 4 9 1 12 4 9 1 copyright c 2014 free software foundation inc this is free software see source for copying conditions there is no warranty not even for or fitness for a particular purpose java debian java eclipse lib i386 linux gnu libstdc so 6 0 20 linux gate so 1 libm so 6 lib i386 linux gnu i686 cmov libm so 6 libc so 6 lib i386 linux gnu i686 cmov libc so 6 lib ld linux so 2 libgcc s so 1 lib i386 linux gnu libgcc s so 1 include using namespace std using namespace gnu cxx class requiredallocation public requiredallocation requiredallocation std basic string char s hello world n requiredallocation requiredallocation cout requiredallocation requiredallocation endl requiredallocation requiredallocation cout requiredallocation requiredallocation endl void alloc gnu cxx new allocator requiredallocation all unsigned int size void pt requiredallocation t try all allocate size pt cout all max size endl for auto e t s cout e catch std bad alloc e cout e what endl int main gnu cxx new allocator requiredallocation all new gnu cxx new allocator requiredallocation requiredallocation t void pt t what happens when new can find no store to allocate by default allocator throws a stan dard library bad alloc exception for an alternative see 2 4 1 c bjarne stroustrup c programming language unsigned int size alloc all size pt t size 1 alloc all size pt t return 0 references external links allocators stl an introductory article c standard allocator an introduction and implementation a custom allocator implementation based on malloc category c standard library category generic programming category articles with example c code