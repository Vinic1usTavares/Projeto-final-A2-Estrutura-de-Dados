300px thumb right greek lowercase omega o character is used to represent null in database theory null or null is a special marker used in structured query language to indicate that a data value does not exist in database introduced by creator of relational database model e f codd sql null serves to fulfil requirement that all true relational database management systems rdbms support a representation of missing information and inapplicable information codd also introduced use of lowercase greek omega o symbol to represent null in database theory in sql null is a reserved word used to identify this marker a null should not be confused with a value of 0 a null value indicates a lack of a value a lack of a value is not same thing as a value of zero in same way that a lack of an answer is not same thing as an answer of no for example consider question how many books does adam own answer may be zero we know that he owns none or null we do not know how many he owns in a database table column reporting this answer would start out with no value marked by null and it would not be updated with value zero until we have ascertained that adam owns no books sql null is a state not a value this usage is quite different from most programming languages where null value of a reference means it is not pointing to any object history e f codd mentioned nulls as a method of representing missing data in relational model in a 1975 paper in fdt bulletin of acm sigmod codd s paper that is most commonly cited in relation with semantics of null as adopted in sql is his 1979 paper in acm transactions on database systems in which he also introduced his relational model tasmania although much of other proposals from latter paper have remained obscure section 2 3 of his 1979 paper details semantics of null propagation in arithmetic operations as well as comparisons employing a ternary three valued logic when comparing to nulls it also details treatment of nulls on other set operations latter issue still controversial today in database theory circles original proposal of codd 1975 1979 is now referred to as codd tables codd later reinforced his requirement that all support null to indicate missing data in a 1985 two part article published in computerworld magazine 1986 sql standard basically adopted codd s proposal after an implementation prototype in ibm system r although don chamberlin recognized nulls alongside duplicate rows as one of most controversial features of sql he defended design of nulls in sql invoking pragmatic arguments that it was least expensive form of system support for missing information saving programmer from many application level checks see problem while at same time providing database designer with option not to use nulls if they so desire for example in order to avoid well known anomalies discussed in semantics section of this article chamberlin also argued that besides providing some missing value functionality practical experience with nulls also led to other language features which rely on nulls like certain grouping constructs and outer joins finally he argued that in practice nulls also end up being used as a quick way to patch an existing schema when it needs to evolve beyond its original intent coding not for missing but rather for inapplicable information for example a database that quickly needs to support electric cars while having a miles per gallon column codd indicated in his 1990 book relational model for database management version 2 that single null mandated by sql standard was inadequate and should be replaced by two separate null type markers to indicate reason why data is missing in codd s book these two null type markers are referred to as a values and i values representing missing but applicable and missing but inapplicable respectively codd s recommendation would have required sql s logic system be expanded to accommodate a four valued logic system because of this additional complexity idea of multiple nulls with different definitions has not gained widespread acceptance in database practitioners domain it remains an active field of research though with numerous papers still being published challenges null has been focus of controversy and a source of debate because of its associated three valued logic 3vl special requirements for its use in sql joins and special handling required by aggregate functions and sql grouping operators computer science professor ron van der meyden summarized various issues as inconsistencies in sql standard mean that it is not possible to ascribe any intuitive logical semantics to treatment of nulls in sql ron van der meyden logical approaches to incomplete information a survey in jan gunter eds logics for databases and information systems kluwer academic publishers p 344 ps preprint note page numbering differs in preprint from published version although various proposals have been made for resolving these issues complexity of alternatives has prevented their widespread adoption null propagation arithmetic operations because null is not a data value but a marker for an absent value using mathematical operators on null gives an unknown result which is represented by null in following example multiplying 10 by null results in null 10 null result is null this can lead to unanticipated results for instance when an attempt is made to divide null by zero platforms may return null instead of throwing an expected data exception division by zero though this behavior is not defined by iso sql standard many dbms vendors treat this operation similarly for instance oracle postgresql mysql server and microsoft sql server platforms all return a null result for following null 0 string concatenation string concatenation operations which are common in sql also result in null when one of operands is null following example demonstrates null result returned by using null with sql string concatenation operator fish null chips result is null this is not true for all database implementations in an oracle rdbms for example null and empty string are considered same thing and therefore fish null chips results in fish chips comparisons with null and three valued logic 3vl since null is not a member of any data domain it is not considered a value but rather a marker or placeholder indicating undefined value because of this comparisons with null can never result in either true or false but always in a third logical result unknown logical result of expression below which compares value 10 to null is unknown select 10 null results in unknown however certain operations on null can return values if absent value is not relevant to outcome of operation consider following example select null or true results in true in this case fact that value on left of or is unknowable is irrelevant because outcome of or operation would be true regardless of value on left sql implements three logical results so sql implementations must provide for a specialized three valued logic 3vl rules governing sql three valued logic are shown in tables below p and q represent logical states truth tables sql uses for and or and not correspond to a common fragment of kleene and three valued logic which differ in their definition of implication however sql defines no such operation p q p or q p and q p q p not p effect of unknown in where clauses sql three valued logic is encountered in data manipulation language dml in comparison predicates of dml statements and queries where clause causes dml statement to act on only those rows for which predicate evaluates to true rows for which predicate evaluates to either false or unknown are not acted on by insert update or delete dml statements and are discarded by select queries interpreting unknown and false as same logical result is a common error encountered while dealing with nulls following simple example demonstrates this fallacy select from t where i null example query above logically always returns zero rows because comparison of i column with null always returns unknown even for those rows where i is null unknown result causes select statement to summarily discard each and every row however in practice some sql tools will retrieve rows using a comparison with null null specific and 3vl specific comparison predicates basic sql comparison operators always return unknown when comparing anything with null so sql standard provides for two special null specific comparison predicates is null and is not null predicates which use a postfix syntax test whether data is or is not null sql standard contains optional feature f571 truth value tests that introduces three additional logical unary operators six in fact if we count their negation which is part of their syntax also using postfix notation they have following truth tables c j date 2004 an introduction to database systems 8th ed pearson education p 594 p p is true p is not true p is false p is not false p is unknown p is not unknown f571 feature is orthogonal to presence of boolean datatype in sql discussed later in this article and despite syntactic similarities f571 does not introduce boolean or three valued literals in language f571 feature was actually present in sql92 well before boolean datatype was introduced to standard in 1999 f571 feature is implemented by few systems however postgresql is one of those implementing it addition of is unknown to other operators of sql s three valued logic makes sql three valued logic functionally complete c j date relational database writings 1991 1994 addison wesley 1995 p 371 meaning its logical operators can express in combination any conceivable three valued logical function on systems which don t support f571 feature it is possible to emulate is unknown p by going over every argument that could make expression p unknown and test those arguments with is null or other null specific functions although this may be more cumbersome law of excluded fourth in where clauses in sql s three valued logic law of excluded middle p or not p no longer evaluates to true for all p more precisely in sql s three valued logic p or not p is unknown precisely when p is unknown and true otherwise because direct comparisons with null result in unknown logical value following query select from stuff where x 10 or not x 10 is not equivalent in sql with select from stuff if column x contains any nulls in that case second query would return some rows first one does not return namely all those in which x is null in classical two valued logic law of excluded middle would allow simplification of where clause predicate in fact its elimination attempting to apply law of excluded middle to sql s 3vl is effectively a false dichotomy second query is actually equivalent with select from stuff is because of 3vl equivalent to select from stuff where x 10 or not x 10 or x is null thus to correctly simplify first statement in sql requires that we return all rows in which x is not null select from stuff where x is not null in view of above observe that for sql s where clause a tautology similar to law of excluded middle can be written assuming is unknown operator is present p or not p or p is unknown is true for every predicate p among logicians this is called law of excluded fourth there are some sql expressions in which it is less obvious where false dilemma occurs for example select ok where 1 not in select cast null as integer union select ok where 1 in select cast null as integer produces no rows because in translates to an iterated version of equality over argument set and 1 null is unknown just as a 1 null is unknown cast in this example is needed only in some sql implementations like postgresql which would reject it with a type checking error otherwise in many systems plain select null works in missing case above is of course select ok where 1 in select cast null as integer is unknown effect of null and unknown in other constructs joins joins evaluate using same comparison rules as for where clauses therefore care must be taken when using columns in sql join criteria in particular a table containing any nulls is not equal with a natural self join of itself meaning that whereas is true for any relation r in relational algebra a sql self join will exclude all rows having a null anywhere c j date 2004 an introduction to database systems 8th ed pearson education p 584 an example of this behavior is given in section analyzing missing value semantics of nulls sql coalesce function or case expressions can be used to simulate null equality in join criteria and is null and is not null predicates can be used in join criteria as well following predicate tests for equality of values a and b and treats nulls as being equal a b or a is null and b is null case expressions sql provides two flavours of conditional expressions one is called simple case and operates like a switch statement other is called a searched case in standard and operates like an if elseif simple case expressions use implicit equality comparisons which operate under same rules as dml where clause rules for null thus a simple case expression cannot check for existence of null directly a check for null in a simple case expression always results in unknown as in following select case i when null then is null this will never be returned when 0 then is zero this will be returned when i 0 when 1 then is one this will be returned when i 1 end from t because expression i null evaluates to unknown no matter what value column i contains even if it contains null string is null will never be returned on other hand a searched case expression can use predicates like is null and is not null in its conditions following example shows how to use a searched case expression to properly check for null select case when i is null then null result this will be returned when i is null when i 0 then zero this will be returned when i 0 when i 1 then one this will be returned when i 1 end from t in searched case expression string null result is returned for all rows in which i is null oracle s dialect of sql provides a built in function decode which can be used instead of simple case expressions and considers two nulls equal select decode i null null result 0 zero 1 one from t finally all these constructs return a null if no match is found they have a default else null clause if statements in procedural extensions sql psm sql persistent stored modules defines procedural extensions for sql such as if statement however major sql vendors have historically included their own proprietary procedural extensions procedural extensions for looping and comparisons operate under null comparison rules similar to those for dml statements and queries following code fragment in iso sql standard format demonstrates use of null 3vl in an if statement if i null then select result is true elseif not i null then select result is false else select result is unknown if statement performs actions only for those comparisons that evaluate to true for statements that evaluate to false or unknown if statement passes control to elseif clause and finally to else clause result of code above will always be message result is unknown since comparisons with null always evaluate to unknown analysis of sql null missing value semantics groundbreaking work of t imielinski and w lipski jr 1984 provided a framework in which to evaluate intended semantics of various proposals to implement missing value semantics that is referred to as imielinski lipski algebras this section roughly follows chapter 19 of alice textbook a similar presentation appears in review of ron van der meyden 4 in selections and projections weak representation constructs representing missing information such as codd tables are actually intended to represent a set of relations one for each possible of their parameters in case of codd tables this means replacement of nulls with some concrete value for example a construct such as a codd table is said to be a strong representation system of missing information if any answer to a query made on construct can be particularized to obtain an answer for any corresponding query on relations it represents which are seen as models of construct more precisely if is a query formula in relational algebra of pure relations and if is its lifting to a construct intended to represent missing information a strong representation has property that for any query q and table construct t lifts all answers to construct i e above has to hold for queries taking any number of tables as arguments but restriction to one table suffices for this discussion clearly codd tables do not have this strong property if selections and projections are considered as part of query language for example all answers to select from emp where age 22 should include possibility that a relation like may exist however codd tables cannot represent disjunction result with possibly 0 or 1 rows a device mostly of theoretical interest called conditional table or c table can however represent such an answer result name age condition harriet o1 o1 22 where condition column is interpreted as row doesn t exist if condition is false it turns out that because formulas in condition column of a c table can be arbitrary propositional logic formulas an algorithm for problem whether a c table represents some concrete relation has a co np complete complexity thus is of little practical worth a weaker notion of representation is therefore desirable imielinski and lipski introduced notion of weak representation which essentially allows lifted queries over a construct to return a representation only for sure information i e if it s valid for all possible world instantiations models of construct concretely a construct is a weak representation system if right hand side of above equation is sure information i e information which can be certainly extracted from database regardless of what values are used to replace nulls in database in example we considered above it s easy to see that intersection of all possible models i e sure information of query selecting where age 22 is actually empty because for instance query returns no rows for relation more generally it was shown by imielinski and lipski that codd tables are a weak representation system if query language is restricted to projections selections and renaming of columns however as soon as we add either joins or unions to query language even this weak property is lost as evidenced in next section if joins or unions are considered not even weak representation consider following query over same codd table emp from previous section select name from emp where age 22 union select name from emp where age 22 whatever concrete value one would choose for null age of harriet above query will return full column of names of any model of emp but when lifted query is run on emp itself harriet will always be missing i e we have query result on emp name george charles query result on any model of emp name george harriet charles thus when unions are added to query language codd tables are not even a weak representation system of missing information meaning that queries over them don t even report all sure information it s important to note here that semantics of union on nulls which are discussed in a later section did not even come into play in this query forgetful nature of two sub queries was all that it took to guarantee that some sure information went unreported when above query was run on codd table emp for natural joins example needed to show that sure information may be unreported by some query is slightly more complicated consider table j f1 f2 f3 11 13 21 23 31 32 33 and query select f1 f3 from select f1 f2 from j as f12 natural join select f2 f3 from j as f23 query result on j f1 f3 31 33 query result on any model of j f1 f3 11 13 21 23 31 33 intuition for what happens above is that codd tables representing projections in subqueries lose track of fact that nulls in columns f12 f2 and f23 f2 are actually copies of originals in table j this observation suggests that a relatively simple improvement of codd tables which works correctly for this example would be to use skolem constants meaning skolem functions which are also constant functions say and instead of a single null symbol such an approach called v tables or naive tables is computationally less expensive that c tables discussed above however it is still not a complete solution for incomplete information in sense that v tables are only a weak representation for queries not using any negations in selection and not using any set difference either first example considered in this section is using a negative selection clause where age 22 so it is also an example where v tables queries would not report sure information check constraints and foreign keys primary place in which sql three valued logic intersects with sql data definition language ddl is in form of check constraints a check constraint placed on a column operates under a slightly different set of rules than those for dml where clause while a dml where clause must evaluate to true for a row a check constraint must not evaluate to false from a logic perspective designated values are true and unknown this means that a check constraint will succeed if result of check is either true or unknown following example table with a check constraint will prohibit any integer values from being inserted into column i but will allow null to be inserted since result of check will always evaluate to unknown for nulls create table t i integer constraint ck i check i 0 and i 0 and i 0 because of change in designated values relative to where clause from a logic perspective law of excluded middle is a tautology for check constraints meaning check p or not p always succeeds furthermore assuming nulls are to be interpreted as existing but unknown values some pathological checks like one above allow insertion of nulls that could never be replaced by any non null value in order to constrain a column to reject nulls not null constraint can be applied as shown in example below not null constraint is semantically equivalent to a check constraint with an is not null predicate create table t i integer not null by default check constraints against foreign keys succeed if any of fields in such keys are null for example table create table books title varchar 100 author last varchar 20 author first varchar 20 foreign key author last author first references authors last name first name would allow insertion of rows where author last or author first are null irrespective of how table authors is defined or what it contains more precisely a null in any of these fields would allow any value in other one even on that is not found in authors table for example if authors contained only doe john then smith null would satisfy foreign key constraint sql 92 added two extra options for narrowing down matches in such cases if match partial is added after references declaration then any non null must match foreign key e g doe null would still match but smith null would not finally if match full is added then smith null would not match constraint either but null null would still match it outer joins 270px thumb right example sql outer join query with null placeholders in result set null markers are represented by word null in place of data in results results are from microsoft sql server as shown in sql server management studio sql outer joins including left outer joins right outer joins and full outer joins automatically produce nulls as placeholders for missing values in related tables for left outer joins for instance nulls are produced in place of rows missing from table appearing on right hand side of left outer join operator following simple example uses two tables to demonstrate null placeholder production in a left outer join first table employee contains employee id numbers and names while second table phonenumber contains related employee id numbers and phone numbers as shown below employee id lastname firstname 1 johnson joe 2 lewis larry 3 thompson thomas 4 patterson patricia phonenumber id number 1 555 2323 3 555 9876 following sample sql query performs a left outer join on these two tables select e id e lastname e firstname pn number from employee e left outer join phonenumber pn on e id pn id result set generated by this query demonstrates how sql uses null as a placeholder for values missing from right hand phonenumber table as shown below query result id lastname firstname number 1 johnson joe 555 2323 2 lewis larry 3 thompson thomas 555 9876 4 patterson patricia aggregate functions sql defines aggregate functions to simplify server side aggregate calculations on data except for count function all aggregate functions perform a null elimination step so that nulls are not included in final result of calculation note that elimination of null is not equivalent to replacing null with zero for example in following table avg i average of values of i will give a different result from that of avg j i j 150 150 200 200 250 250 0 here avg i is 200 average of 150 200 and 250 while avg j is 150 average of 150 200 250 and 0 a well known side effect of this is that in sql avg z is not equivalent with sum z count output of an aggregate function can also be null here is an example select count min e wage max e wage from employee e where e lastname like jones this query will always output exactly one row counting of number of employees whose last name contains jones and giving minimum and maximum wage found for those employees however what happens if none of employees fit given criteria calculating minimum or maximum value of an empty set is impossible so those results must be null indicating there is no answer this is not an unknown value it is a null representing absence of a value result would be count min e wage max e wage 0 when two nulls are equal grouping sorting and some set operations because sql 2003 defines all null markers as being unequal to one another a special definition was required in order to group nulls together when performing certain operations sql defines any two values that are equal to one another or any two nulls as not distinct this definition of not distinct allows sql to group and sort nulls when group by clause and other keywords that perform grouping are used other sql operations clauses and keywords use not distinct in their treatment of nulls these include following partition by clause of ranking and windowing functions like row number union intersect and except operator which treat nulls as same for row comparison elimination purposes distinct keyword used in select queries principle that nulls aren t equal to each other but rather that result is unknown is effectively violated in sql specification for union operator which does identify nulls with each other consequently some set operations in sql like union or difference may produce results not representing sure information unlike operations involving explicit comparisons with null e g those in a where clause discussed above in codd s 1979 proposal which was basically adopted by sql92 this semantic inconsistency is rationalized by arguing that removal of duplicates in set operations happens at a lower level of detail than equality testing in evaluation of retrieval operations sql standard does not explicitly define a default sort order for nulls instead on conforming systems nulls can be sorted before or after all data values by using nulls first or nulls last clauses of order by list respectively not all dbms vendors implement this functionality however vendors who do not implement this functionality may specify different treatments for null sorting in dbms effect on index operation some sql products do not index keys containing nulls for instance postgresql versions prior to 8 3 did not with documentation for a b tree index stating that in cases where index enforces uniqueness nulls are excluded from index and uniqueness is not enforced between nulls again quoting from postgresql documentation this is consistent with sql 2003 defined behavior of scalar null comparisons another method of indexing nulls involves handling them as not distinct in accordance with sql 2003 defined behavior for example microsoft sql server documentation states following both of these indexing strategies are consistent with sql 2003 defined behavior of nulls because indexing methodologies are not explicitly defined by sql 2003 standard indexing strategies for nulls are left entirely to vendors to design and implement null handling functions sql defines two functions to explicitly handle nulls nullif and coalesce both functions are abbreviations for searched case expressions nullif nullif function accepts two parameters if first parameter is equal to second parameter nullif returns null otherwise value of first parameter is returned nullif value1 value2 thus nullif is an abbreviation for following case expression case when value1 value2 then null else value1 end coalesce coalesce function accepts a list of parameters returning first non null value from list coalesce value1 value2 value3 coalesce is defined as shorthand for following sql case expression case when value1 is not null then value1 when value2 is not null then value2 when value3 is not null then value3 end some sql implement vendor specific functions similar to coalesce some systems e g transact sql implement an function or other similar functions that are functionally similar to coalesce see is functions for more on is functions in transact sql nvl oracle nvl function accepts two parameters it returns first non null parameter or null if all parameters are null a coalesce expression can be converted into an equivalent nvl expression thus coalesce val1 val n turns into nvl val1 nvl nvl nvl val n 1 val n a use case of this function is to replace in an expression a null by a value like in nvl salary 0 which says if salary is null replace it with value 0 there is however one notable exception in most implementations coalesce evaluates its parameters until it reaches first non null one while nvl evaluates all of its parameters this is important for several reasons a parameter after first non null parameter could be a function which could either be computationally expensive invalid or could create unexpected side effects data typing of null and unknown null literal is in sql meaning that it is not designated as an integer character or any other specific data type because of this it is sometimes mandatory or desirable to explicitly convert nulls to a specific data type for instance if overloaded functions are supported by rdbms sql might not be able to automatically resolve to correct function without knowing data types of all parameters including those for which null is passed conversion from null literal to a null of a specific type is possible using cast introduced in sql 92 for example cast null as integer represents an absent value of type integer actual typing of unknown distinct or not from null itself varies between sql implementations for example following select ok where null 1 is null parses and executes successfully in some environments e g or postgresql which unify a null boolean with unknown but fails to parse in others e g in sql server compact mysql behaves similarly to postgresql in this regard with minor exception that mysql regards true and false as no different from ordinary integers 1 and 0 postgresql additionally implements a is unknown predicate which can be used to test whether a three value logical outcome is unknown although this is merely syntactic sugar boolean data type iso sql 1999 standard introduced boolean data type to sql however it s still just an optional non core feature coded t031 when restricted by a not null constraint sql boolean works like boolean type from other languages unrestricted however boolean datatype despite its name can hold truth values true false and unknown all of which are defined as boolean literals according to standard standard also asserts that null and unknown may be used interchangeably to mean exactly same thing iso iec 2 2011 ss4 5 boolean type has been subject of criticism particularly because of mandated behavior of unknown literal which is never equal to itself because of identification with null as discussed above in postgresql implementation of sql null is used to represent all unknown results including unknown boolean postgresql does not implement unknown literal although it does implement is unknown operator which is an orthogonal feature most other major vendors do not support boolean type as defined in t031 as of 2012 troels arvin survey of boolean data type implementation procedural part of oracle s pl sql supports boolean however variables these can also be assigned null and value is considered same as unknown controversy common mistakes misunderstanding of how null works is cause of a great number of errors in sql code both in iso standard sql statements and in specific sql dialects supported by real world database management systems these mistakes are usually result of confusion between null and either 0 zero or an empty string a string value with a length of zero represented in sql as null is defined by sql standard as different from both an empty string and numerical value 0 however while null indicates absence of any value empty string and numerical zero both represent actual values a classic error is attempt to use equals operator in combination with keyword null to find rows with nulls according to sql standard this is an invalid syntax and shall lead to an error message or an exception but most implementations accept syntax and evaluate such expressions to unknown consequence is that no rows are found regardless of whether rows with nulls exist or not proposed way to retrieve rows with nulls is use of predicate is null instead of null select from sometable where num null should be where num is null in a related but more subtle example a where clause or conditional statement might compare a column s value with a constant it is often incorrectly assumed that a missing value would be less than or not equal to a constant if that field contains null but in fact such expressions return unknown an example is below select from sometable where num 1 rows where num is null will not be returned contrary to many users expectations these confusions arise because law of identity is restricted in sql s logic when dealing with equality comparisons using null literal or unknown truth value sql will always return unknown as result of expression this is a partial equivalence relation and makes sql an example of a non reflexive logic similarly nulls are often confused with empty strings consider length function which returns number of characters in a string when a null is passed into this function function returns null this can lead to unexpected results if users are not well versed in 3 value logic an example is below select from sometable where length string 20 rows where string is null will not be returned this is complicated by fact that in some database interface programs or even database implementations like oracle s null is reported as an empty string and empty strings may be incorrectly stored as null criticisms iso sql implementation of null is subject of criticism debate and calls for change in relational model for database management version 2 codd suggested that sql implementation of null was flawed and should be replaced by two distinct null type markers markers he proposed were to stand for missing but applicable and missing but inapplicable known as a values and i values respectively codd s recommendation if accepted would have required implementation of a four valued logic in sql others have suggested adding additional null type markers to codd s recommendation to indicate even more reasons that a data value might be missing increasing complexity of sql s logic system at various times proposals have also been put forth to implement multiple user defined null markers in sql because of complexity of null handling and logic systems required to support multiple null markers none of these proposals have gained widespread acceptance chris date and hugh darwen authors of third manifesto have suggested that sql null implementation is inherently flawed and should be eliminated altogether pointing to inconsistencies and flaws in implementation of sql null handling particularly in aggregate functions as proof that entire concept of null is flawed and should be removed from relational model others like author fabian pascal have stated a belief that how function calculation should treat missing values is not governed by relational model closed world assumption another point of conflict concerning nulls is that they violate closed world assumption model of relational databases by introducing an open world assumption into it closed world assumption as it pertains to databases states that everything stated by database either explicitly or implicitly is true everything else is false this view assumes that knowledge of world stored within a database is complete nulls however operate under open world assumption in which some items stored in database are considered unknown making database s stored knowledge of world incomplete see also sql nulls in sql tutorial d ternary logic data manipulation language codd s 12 rules check constraint relational model tasmania relational database management system join sql third manifesto references further reading e f codd understanding relations installment 7 fdt bulletin of acm sigmod 7 3 4 23 28 1975 especially ss2 3 claude nulls three valued logic and ambiguity in sql critiquing date s critique sigmod record december 2007 vol 36 no 4 john grant null values in sql sigmod record september 2008 vol 37 no 3 and null semantics for subqueries and atomic predicates international journal of computer science 35 3 2008 305 313 enrico and sergio on logic of sql nulls proceedings of 6th alberto international workshop on foundations of data management ouro preto brazil june 27 30 2012 pp 114 128 external links oracle nulls third manifesto implications of nulls in sequencing of data java bug report about not distinguishing null and empty string which sun closed as not a bug category sql keywords category articles with example sql code category unknown content